<HTML>
<HEAD>
<TITLE>Modelica.Mechanics.Rotational</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Library to model 1-dimensional, rotational mechanical systems&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal}
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Rotational<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Mechanics.Rotational"></A><A HREF="Modelica_Mechanics.html#Modelica.Mechanics"
>Modelica.Mechanics</A>.Rotational</H2>
<B>Library to model 1-dimensional, rotational mechanical systems</B>
<P>
<H3>Information</H3>
<PRE></pre>

<p>
Library <b>Rotational</b> is a <b>free</b> Modelica package providing
1-dimensional, rotational mechanical components to model in a convenient way
drive trains with frictional losses. A typical, simple example is shown
in the next figure:
</p>

<p><img src="../Images/Rotational/driveExample.png"></p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <A HREF="Modelica_Mechanics_Rotational_UsersGuide.html#696fa8fedf41b527ional.UsersGuide"
>Rotational.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <A HREF="Modelica_Mechanics_Rotational_Examples.html#3ec550c73946fef5ational.Examples"
>Rotational.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>

<p>
Copyright &copy; 1998-2007, Modelica Association and DLR.
</p>
<p>
<i>This Modelica package is <b>free</b> software; it can be redistributed and/or modified
under the terms of the <b>Modelica license</b>, see the license conditions
and the accompanying <b>disclaimer</b>
<A HREF="Modelica_UsersGuide.html#Modelica.UsersGuide.ModelicaLicense"
>here</a>.</i>
</p><br>
<pre>
</PRE><P>
<H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.UsersGuideS.png" ALT="Modelica.Mechanics.Rotational.UsersGuide" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational_UsersGuide.html#696fa8fedf41b527ional.UsersGuide"
>UsersGuide</A>
</TD><TD>User's Guide of Rotational Library</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.ExamplesS.png" ALT="Modelica.Mechanics.Rotational.Examples" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational_Examples.html#3ec550c73946fef5ational.Examples"
>Examples</A>
</TD><TD>Demonstration examples of the components of this package</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.SensorsS.png" ALT="Modelica.Mechanics.Rotational.Sensors" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational_Sensors.html#Modelica.Mechanics.Rotational.Sensors"
>Sensors</A>
</TD><TD>Sensors to measure variables in 1D rotational mechanical components</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.InterfacesS.png" ALT="Modelica.Mechanics.Rotational.Interfaces" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational_Interfaces.html#f1e339701f58009cional.Interfaces"
>Interfaces</A>
</TD><TD>Connectors and partial models for 1D rotational mechanical components</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.InertiaS.png" ALT="Modelica.Mechanics.Rotational.Inertia" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Inertia"
>Inertia</A>
</TD><TD>1D-rotational component with inertia</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.IdealGearS.png" ALT="Modelica.Mechanics.Rotational.IdealGear" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#ecb5380e310a507ctional.IdealGear"
>IdealGear</A>
</TD><TD>Ideal gear without inertia</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.IdealPlanetaryS.png" ALT="Modelica.Mechanics.Rotational.IdealPlanetary" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#41ec86dd760989d1l.IdealPlanetary"
>IdealPlanetary</A>
</TD><TD>Ideal planetary gear box</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.IdealGearR2TS.png" ALT="Modelica.Mechanics.Rotational.IdealGearR2T" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#4586b946280b5691nal.IdealGearR2T"
>IdealGearR2T</A>
</TD><TD>Gearbox transforming rotational into translational motion</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.SpringS.png" ALT="Modelica.Mechanics.Rotational.Spring" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Spring"
>Spring</A>
</TD><TD>Linear 1D rotational spring</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.DamperS.png" ALT="Modelica.Mechanics.Rotational.Damper" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Damper"
>Damper</A>
</TD><TD>Linear 1D rotational damper</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.SpringDamperS.png" ALT="Modelica.Mechanics.Rotational.SpringDamper" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#ee31a5b06756bc4fnal.SpringDamper"
>SpringDamper</A>
</TD><TD>Linear 1D rotational spring and damper in parallel</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.ElastoBacklashS.png" ALT="Modelica.Mechanics.Rotational.ElastoBacklash" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#60da7067eeaeb788l.ElastoBacklash"
>ElastoBacklash</A>
</TD><TD>Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.BearingFrictionS.png" ALT="Modelica.Mechanics.Rotational.BearingFriction" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#3853572291d81c7f.BearingFriction"
>BearingFriction</A>
</TD><TD>Coulomb friction in bearings </TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.ClutchS.png" ALT="Modelica.Mechanics.Rotational.Clutch" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Clutch"
>Clutch</A>
</TD><TD>Clutch based on Coulomb friction </TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.OneWayClutchS.png" ALT="Modelica.Mechanics.Rotational.OneWayClutch" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#8b5343c0e7f072eanal.OneWayClutch"
>OneWayClutch</A>
</TD><TD>Series connection of freewheel and clutch</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.BrakeS.png" ALT="Modelica.Mechanics.Rotational.Brake" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Brake"
>Brake</A>
</TD><TD>Brake based on Coulomb friction </TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.LossyGearS.png" ALT="Modelica.Mechanics.Rotational.LossyGear" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#ce8c5f7b945a5521tional.LossyGear"
>LossyGear</A>
</TD><TD>Gear with mesh efficiency and bearing friction (stuck/rolling possible)</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.GearEfficiencyS.png" ALT="Modelica.Mechanics.Rotational.GearEfficiency" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#e3b7edc27e8821bfl.GearEfficiency"
>GearEfficiency</A>
</TD><TD>Obsolete component (use model LossyGear instead)</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.GearS.png" ALT="Modelica.Mechanics.Rotational.Gear" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Gear"
>Gear</A>
</TD><TD>Realistic model of a gearbox</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.Gear2S.png" ALT="Modelica.Mechanics.Rotational.Gear2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Gear2"
>Gear2</A>
</TD><TD>Realistic model of a gearbox (based on LossyGear)</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.PositionS.png" ALT="Modelica.Mechanics.Rotational.Position" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#6f7bfddbdd04eb05ational.Position"
>Position</A>
</TD><TD>Forced movement of a flange according to a reference angle signal</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.PositionS.png" ALT="Modelica.Mechanics.Rotational.Speed" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Speed"
>Speed</A>
</TD><TD>Forced movement of a flange according to a reference angular velocity signal</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.PositionS.png" ALT="Modelica.Mechanics.Rotational.Accelerate" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#5d4d9d8723608712ional.Accelerate"
>Accelerate</A>
</TD><TD>Forced movement of a flange according to an acceleration signal</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.MoveS.png" ALT="Modelica.Mechanics.Rotational.Move" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Move"
>Move</A>
</TD><TD>Forced movement of a flange according to an angle, speed and angular acceleration signal</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.FixedS.png" ALT="Modelica.Mechanics.Rotational.Fixed" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Fixed"
>Fixed</A>
</TD><TD>Flange fixed in housing at a given angle</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.TorqueS.png" ALT="Modelica.Mechanics.Rotational.Torque" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Torque"
>Torque</A>
</TD><TD>Input signal acting as external torque on a flange</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.Torque2S.png" ALT="Modelica.Mechanics.Rotational.Torque2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Torque2"
>Torque2</A>
</TD><TD>Input signal acting as torque on two flanges</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.LinearSpeedDependentTorqueS.png" ALT="Modelica.Mechanics.Rotational.LinearSpeedDependentTorque" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#781da0e966a52564dDependentTorque"
>LinearSpeedDependentTorque</A>
</TD><TD>Linear dependency of torque versus speed</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorqueS.png" ALT="Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorque" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#5e6f29c07eaacd0edDependentTorque"
>QuadraticSpeedDependentTorque</A>
</TD><TD>Quadratic dependency of torque versus speed</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.ConstantTorqueS.png" ALT="Modelica.Mechanics.Rotational.ConstantTorque" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#24b3d1c0f761f82cl.ConstantTorque"
>ConstantTorque</A>
</TD><TD>Constant torque, not dependent on speed</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.ConstantSpeedS.png" ALT="Modelica.Mechanics.Rotational.ConstantSpeed" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#37270de94c44d153al.ConstantSpeed"
>ConstantSpeed</A>
</TD><TD>Constant speed, not dependent on torque</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.TorqueStepS.png" ALT="Modelica.Mechanics.Rotational.TorqueStep" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#8de49d8c1172fdaaional.TorqueStep"
>TorqueStep</A>
</TD><TD>Constant torque, not dependent on speed</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.RelativeStatesS.png" ALT="Modelica.Mechanics.Rotational.RelativeStates" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#9b98d1d4199066dcl.RelativeStates"
>RelativeStates</A>
</TD><TD>Definition of relative state variables</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.InitializeFlangeS.png" ALT="Modelica.Mechanics.Rotational.InitializeFlange" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational.html#770f8c3f10ba9fe4InitializeFlange"
>InitializeFlange</A>
</TD><TD>Initializes a flange with pre-defined angle, speed and angular acceleration (usually, this is reference data from a control bus)</TD></TR>
<TR><TD><IMG SRC="Modelica.Mechanics.Rotational.TypesS.png" ALT="Modelica.Mechanics.Rotational.Types" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Mechanics_Rotational_Types.html#Modelica.Mechanics.Rotational.Types"
>Types</A>
</TD><TD>Constants and types with choices, especially to build menus</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Inertia<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.InertiaI.png" ALT="Modelica.Mechanics.Rotational.Inertia" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Inertia"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Inertia</H2>
<B>1D-rotational component with inertia</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.InertiaD.png" ALT="Modelica.Mechanics.Rotational.Inertia">
<H3>Information</H3>
<PRE></pre>
<p>
Rotational component with <b>inertia</b> and two rigidly connected flanges.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Inertia"
>Inertia</A></TD><TD>J</TD><TD>1</TD><TD>Moment of inertia [kg.m2]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Types_Init.html#eaf0b4b774f806de.Types.Init.Temp"
>Temp</A></TD><TD>initType</TD><TD>Modelica.Mechanics.Rotationa...</TD><TD>Type of initialization (defines usage of start values below)</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_start</TD><TD>0</TD><TD>Initial or guess value of rotor rotation angle phi [rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_start</TD><TD>0</TD><TD>Initial or guess value of angular velocity w = der(phi) [rad/s]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>AngularAcceleration</A></TD><TD>a_start</TD><TD>0</TD><TD>Initial value of angular acceleration a = der(w) [rad/s2]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi.start</TD><TD>phi_start</TD><TD>Absolute rotation angle of component (= flange_a.phi = flange_b.phi) [rad]</TD></TR>
<TR bgcolor="#c0c0c0"><TD colspan=4><B>Advanced</B></TD></TR>
<TR><TD><A HREF="Modelica_Blocks_Types_StateSelection.html#f20e56826b4d9061teSelection.Temp"
>Temp</A></TD><TD>stateSelection</TD><TD>Modelica.Blocks.Types.StateS...</TD><TD>Priority to use phi and w as states</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>(left) driving flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) driven flange (flange axis directed OUT OF cut plane)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Inertia <font color="darkgreen">&quot;1D-rotational component with inertia&quot;</font>
  <font color="blue">import </font>SI = <A HREF="Modelica_SIunits.html#Modelica.SIunits"
>Modelica.SIunits</A>;
  <font color="blue">import </font><A HREF="Modelica_Mechanics_Rotational_Types_Init.html#63932d1319cf823bional.Types.Init"
>Modelica.Mechanics.Rotational.Types.Init</A>;
  <font color="blue">import </font><A HREF="Modelica_Blocks_Types_StateSelection.html#Modelica.Blocks.Types.StateSelection"
>Modelica.Blocks.Types.StateSelection</A>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Inertia"
>SI.Inertia</A> J(min=0)=1 <font color="darkgreen">&quot;Moment of inertia&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_Mechanics_Rotational_Types_Init.html#eaf0b4b774f806de.Types.Init.Temp"
>Init.Temp</A> initType=Modelica.Mechanics.Rotational.Types.Init.NoInit <font color="darkgreen">
    &quot;Type of initialization (defines usage of start values below)&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_start=0 <font color="darkgreen">
    &quot;Initial or guess value of rotor rotation angle phi&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_start=0 <font color="darkgreen">
    &quot;Initial or guess value of angular velocity w = der(phi)&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a_start=0 <font color="darkgreen">
    &quot;Initial value of angular acceleration a = der(w)&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_Blocks_Types_StateSelection.html#f20e56826b4d9061teSelection.Temp"
>StateSelection.Temp</A> stateSelection=
            Modelica.Blocks.Types.StateSelection.Default <font color="darkgreen">
    &quot;Priority to use phi and w as states&quot;</font>;

  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#2c9977dd5ec310e3Interfaces.Rigid"
>Interfaces.Rigid</A>(phi(start=phi_start,stateSelect=
           <font color="blue">if </font>stateSelection==StateSelection.Never<font color="blue"> then </font>
              StateSelect.never<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Avoid<font color="blue"> then </font>
              StateSelect.avoid<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Default<font color="blue"> then </font>
              StateSelect.default<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Prefer<font color="blue"> then </font>
              StateSelect.prefer<font color="blue"> else </font>StateSelect.always));
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w(start=w_start, stateSelect=
           <font color="blue">if </font>stateSelection==StateSelection.Never<font color="blue"> then </font>
              StateSelect.never<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Avoid<font color="blue"> then </font>
              StateSelect.avoid<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Default<font color="blue"> then </font>
              StateSelect.default<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Prefer<font color="blue"> then </font>
              StateSelect.prefer<font color="blue"> else </font>StateSelect.always) <font color="darkgreen">
    &quot;Absolute angular velocity of component&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a <font color="darkgreen">&quot;Absolute angular acceleration of component&quot;</font>;

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="blue">if </font>initType == Init.SteadyState<font color="blue"> then</font>
    <font color="red"> der</font>(phi) = 0;
    <font color="red"> der</font>(w)   = 0;
  <font color="blue">elseif </font>initType == Init.InitialState<font color="blue"> then</font>
     phi = phi_start;
     w = w_start;
  <font color="blue">elseif </font>initType == Init.InitialAngle<font color="blue"> then</font>
     phi = phi_start;
  <font color="blue">elseif </font>initType == Init.InitialSpeed<font color="blue"> then</font>
     w = w_start;
  <font color="blue">elseif </font>initType == Init.InitialAcceleration<font color="blue"> then</font>
     a = a_start;
  <font color="blue">elseif </font>initType == Init.InitialAngleAcceleration<font color="blue"> then</font>
     phi = phi_start;
     a = a_start;
  <font color="blue">elseif </font>initType == Init.InitialSpeedAcceleration<font color="blue"> then</font>
     w = w_start;
     a = a_start;
  <font color="blue">elseif </font>initType == Init.InitialAngleSpeedAcceleration<font color="blue"> then</font>
     phi = phi_start;
     w = w_start;
     a = a_start;
  <font color="blue">end if</font>;
<font color="blue">equation </font>
  w =<font color="red"> der</font>(phi);
  a =<font color="red"> der</font>(w);
  J*a = flange_a.tau + flange_b.tau;
<font color="blue">end </font>Inertia;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE IdealGear<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.IdealGearI.png" ALT="Modelica.Mechanics.Rotational.IdealGear" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ecb5380e310a507ctional.IdealGear"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.IdealGear</H2>
<B>Ideal gear without inertia</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.IdealGearD.png" ALT="Modelica.Mechanics.Rotational.IdealGear">
<H3>Information</H3>
<PRE></pre>
<p>
This element characterices any type of gear box which is fixed in the
ground and which has one driving shaft and one driven shaft.
The gear is <b>ideal</b>, i.e., it does not have inertia, elasticity, damping
or backlash. If these effects have to be considered, the gear has to be
connected to other elements in an appropriate way.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>ratio</TD><TD>1</TD><TD>Transmission ratio (flange_a.phi/flange_b.phi)</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> IdealGear <font color="darkgreen">&quot;Ideal gear without inertia&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#9883c0136ee2a6f8langesAndBearing"
>Interfaces.TwoFlangesAndBearing</A>;
  <font color="blue">parameter </font>Real ratio=1 <font color="darkgreen">&quot;Transmission ratio (flange_a.phi/flange_b.phi)&quot;</font>;

<font color="blue">equation </font>
  phi_a = ratio*phi_b;
  0 = ratio*flange_a.tau + flange_b.tau;
<font color="blue">end </font>IdealGear;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE IdealPlanetary<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.IdealPlanetaryI.png" ALT="Modelica.Mechanics.Rotational.IdealPlanetary" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="41ec86dd760989d1l.IdealPlanetary"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.IdealPlanetary</H2>
<B>Ideal planetary gear box</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.IdealPlanetaryD.png" ALT="Modelica.Mechanics.Rotational.IdealPlanetary">
<H3>Information</H3>
<PRE></pre>
<p>
The IdealPlanetary gear box is an ideal gear without inertia,
elasticity, damping or backlash consisting
of an inner <b>sun</b> wheel, an outer <b>ring</b> wheel and a
<b>planet</b> wheel located between sun and ring wheel. The bearing
of the planet wheel shaft is fixed in the planet <b>carrier</b>.
The component can be connected to other elements at the
sun, ring and/or carrier flanges. It is not possible to connect
to the planet wheel. If inertia shall not be neglected,
the sun, ring and carrier inertias can be easily added by attaching
inertias (= model Inertia) to the corresponding connectors.
The inertias of the planet wheels are always neglected.
</p>
<p>
The icon of the planetary gear signals that the sun and carrier
flanges are on the left side and the ring flange is on the right side
of the gear box. However, this component is generic and is valid
independantly how the flanges are actually placed (e.g. sun wheel
may be placed on the right side instead on the left side in reality).
</p>
<p>
The ideal planetary gearbox is uniquely defined by the ratio
of the number of ring teeth zr with respect to the number of
sun teeth zs. For example, if there are 100 ring teeth and
50 sun teeth then ratio = zr/zs = 2. The number of planet teeth
zp has to fulfill the following relationship:
</p>
<pre>
   <b>zp := (zr - zs) / 2</b>
</pre>
<p>
Therefore, in the above example zp = 25 is required.
</p>
<p>
According to the overall convention, the positive direction of all
vectors, especially the absolute angular velocities and cut-torques
in the flanges, are along the axis vector displayed in the icon.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>ratio</TD><TD>100/50</TD><TD>number of ring_teeth/sun_teeth (e.g. ratio=100/50)</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>sun</TD><TD>sun flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>carrier</TD><TD>carrier flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>ring</TD><TD>ring flange (flange axis directed OUT OF cut plane)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> IdealPlanetary <font color="darkgreen">&quot;Ideal planetary gear box&quot;</font>
  <font color="blue">parameter </font>Real ratio=100/50 <font color="darkgreen">
    &quot;number of ring_teeth/sun_teeth (e.g. ratio=100/50)&quot;</font>;

  <font color="darkgreen">// kinematic relationship</font>
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> sun <font color="darkgreen">&quot;sun flange (flange axis directed INTO cut plane)&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> carrier <font color="darkgreen">
    &quot;carrier flange (flange axis directed INTO cut plane)&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> ring <font color="darkgreen">
    &quot;ring flange (flange axis directed OUT OF cut plane)&quot;</font>;
<font color="blue">equation </font>
  (1 + ratio)*carrier.phi = sun.phi + ratio*ring.phi;

  <font color="darkgreen">// torque balance (no inertias)</font>
  ring.tau = ratio*sun.tau;
  carrier.tau = -(1 + ratio)*sun.tau;
<font color="blue">end </font>IdealPlanetary;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE IdealGearR2T<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.IdealGearR2TI.png" ALT="Modelica.Mechanics.Rotational.IdealGearR2T" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="4586b946280b5691nal.IdealGearR2T"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.IdealGearR2T</H2>
<B>Gearbox transforming rotational into translational motion</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.IdealGearR2TD.png" ALT="Modelica.Mechanics.Rotational.IdealGearR2T">
<H3>Information</H3>
<PRE></pre>
This is an ideal mass- and inertialess gearbox which transforms a
1D-rotational into a 1D-translational motion. If elasticity, damping
or backlash has to be considered, this ideal gearbox has to be
connected with corresponding elements.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>ratio</TD><TD>1</TD><TD>transmission ratio (flange_a.phi/flange_b.s) [rad/m]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Translational_Interfaces.html#a3f2a0d703f9d497erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearingR</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Translational_Interfaces.html#a3f2a0d603f9d494erfaces.Flange_a"
>Flange_a</A></TD><TD>bearingT</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> IdealGearR2T <font color="darkgreen">
  &quot;Gearbox transforming rotational into translational motion&quot;</font>

  <font color="blue">parameter </font>Real ratio(<font color="blue">final </font>unit=&quot;rad/m&quot;) = 1 <font color="darkgreen">
    &quot;transmission ratio (flange_a.phi/flange_b.s)&quot;</font>;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau_support;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>SI.Force</A> f_support;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> flange_a;
  <A HREF="Modelica_Mechanics_Translational_Interfaces.html#a3f2a0d703f9d497erfaces.Flange_b"
>Modelica.Mechanics.Translational.Interfaces.Flange_b</A> flange_b;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> bearingR;
  <A HREF="Modelica_Mechanics_Translational_Interfaces.html#a3f2a0d603f9d494erfaces.Flange_a"
>Translational.Interfaces.Flange_a</A> bearingT;
<font color="blue">equation </font>
  (flange_a.phi - bearingR.phi) = ratio*(flange_b.s - bearingT.s);
  0 = ratio*flange_a.tau + flange_b.f;

  0 = flange_a.tau + tau_support;
  0 = flange_b.f + f_support;

  <font color="blue">if </font><font color="red">cardinality</font>(bearingR) == 0<font color="blue"> then</font>
    bearingR.phi = 0;
  <font color="blue">else</font>
    bearingR.tau = tau_support;
  <font color="blue">end if</font>;

  <font color="blue">if </font><font color="red">cardinality</font>(bearingT) == 0<font color="blue"> then</font>
    bearingT.s = 0;
  <font color="blue">else</font>
    bearingT.f = f_support;
  <font color="blue">end if</font>;
<font color="blue">end </font>IdealGearR2T;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Spring<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.SpringI.png" ALT="Modelica.Mechanics.Rotational.Spring" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Spring"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Spring</H2>
<B>Linear 1D rotational spring</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.SpringD.png" ALT="Modelica.Mechanics.Rotational.Spring">
<H3>Information</H3>
<PRE></pre>
<p>
A <b>linear 1D rotational spring</b>. The component can be connected either
between two inertias/gears to describe the shaft elasticity, or between
a inertia/gear and the housing (component Fixed), to describe
a coupling of the element with the housing via a spring.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c</TD><TD>&nbsp;</TD><TD>Spring constant [N.m/rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel0</TD><TD>0</TD><TD>Unstretched spring angle [rad]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel.start</TD><TD>0</TD><TD>Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>(left) driving flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) driven flange (flange axis directed OUT OF cut plane)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Spring <font color="darkgreen">&quot;Linear 1D rotational spring&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#f545543dcc80f4b7rfaces.Compliant"
>Interfaces.Compliant</A>;
  <font color="blue">parameter </font>Real c(<font color="blue">final </font>unit=&quot;N.m/rad&quot;, <font color="blue">final </font>min=0) <font color="darkgreen">&quot;Spring constant&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_rel0=0 <font color="darkgreen">&quot;Unstretched spring angle&quot;</font>;

<font color="blue">equation </font>
  tau = c*(phi_rel - phi_rel0);
<font color="blue">end </font>Spring;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Damper<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.DamperI.png" ALT="Modelica.Mechanics.Rotational.Damper" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Damper"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Damper</H2>
<B>Linear 1D rotational damper</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.DamperD.png" ALT="Modelica.Mechanics.Rotational.Damper">
<H3>Information</H3>
<PRE></pre>
<p>
<b>Linear, velocity dependent damper</b> element. It can be either connected
between an inertia or gear and the housing (component Fixed), or
between two inertia/gear elements.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>d</TD><TD>0</TD><TD>Damping constant [N.m.s/rad]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel.start</TD><TD>0</TD><TD>Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>(left) driving flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) driven flange (flange axis directed OUT OF cut plane)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Damper <font color="darkgreen">&quot;Linear 1D rotational damper&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#f545543dcc80f4b7rfaces.Compliant"
>Interfaces.Compliant</A>;
  <font color="blue">parameter </font>Real d(
    <font color="blue">final </font>unit=&quot;N.m.s/rad&quot;,
    <font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;Damping constant&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_rel <font color="darkgreen">
    &quot;Relative angular velocity between flange_b and flange_a&quot;</font>;
<font color="blue">equation </font>
  w_rel =<font color="red"> der</font>(phi_rel);
  tau = d*w_rel;
<font color="blue">end </font>Damper;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE SpringDamper<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.SpringDamperI.png" ALT="Modelica.Mechanics.Rotational.SpringDamper" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ee31a5b06756bc4fnal.SpringDamper"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.SpringDamper</H2>
<B>Linear 1D rotational spring and damper in parallel</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.SpringDamperD.png" ALT="Modelica.Mechanics.Rotational.SpringDamper">
<H3>Information</H3>
<PRE></pre>
<p>
A <b>spring</b> and <b>damper</b> element <b>connected in parallel</b>.
The component can be
connected either between two inertias/gears to describe the shaft elasticity
and damping, or between an inertia/gear and the housing (component Fixed),
to describe a coupling of the element with the housing via a spring/damper.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c</TD><TD>&nbsp;</TD><TD>Spring constant [N.m/rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel0</TD><TD>0</TD><TD>Unstretched spring angle [rad]</TD></TR>
<TR><TD>Real</TD><TD>d</TD><TD>0</TD><TD>Damping constant [N.m.s/rad]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Types_InitRel.html#fbaa30c85551a040pes.InitRel.Temp"
>Temp</A></TD><TD>initType</TD><TD>Modelica.Mechanics.Rotationa...</TD><TD>Type of initialization (defines usage of start values below)</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel_start</TD><TD>0</TD><TD>Initial or guess value of relative rotation angle phi_rel [rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_rel_start</TD><TD>0</TD><TD>Initial or guess value of relative angular velocity w_rel = der(phi_rel) [rad/s]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel.start</TD><TD>phi_rel_start</TD><TD>Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</TD></TR>
<TR bgcolor="#c0c0c0"><TD colspan=4><B>Advanced</B></TD></TR>
<TR><TD><A HREF="Modelica_Blocks_Types_StateSelection.html#f20e56826b4d9061teSelection.Temp"
>Temp</A></TD><TD>stateSelection</TD><TD>Modelica.Blocks.Types.StateS...</TD><TD>Priority to use phi_rel and w_rel as states</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>(left) driving flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) driven flange (flange axis directed OUT OF cut plane)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> SpringDamper <font color="darkgreen">
  &quot;Linear 1D rotational spring and damper in parallel&quot;</font>
  <font color="blue">import </font>SI = <A HREF="Modelica_SIunits.html#Modelica.SIunits"
>Modelica.SIunits</A>;
  <font color="blue">import </font><A HREF="Modelica_Mechanics_Rotational_Types_InitRel.html#8b46ae7ec09cc82bal.Types.InitRel"
>Modelica.Mechanics.Rotational.Types.InitRel</A>;
  <font color="blue">import </font><A HREF="Modelica_Blocks_Types_StateSelection.html#Modelica.Blocks.Types.StateSelection"
>Modelica.Blocks.Types.StateSelection</A>;
  <font color="blue">parameter </font>Real c(<font color="blue">final </font>unit=&quot;N.m/rad&quot;, <font color="blue">final </font>min=0) <font color="darkgreen">&quot;Spring constant&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_rel0=0 <font color="darkgreen">&quot;Unstretched spring angle&quot;</font>;
  <font color="blue">parameter </font>Real d(
    <font color="blue">final </font>unit=&quot;N.m.s/rad&quot;,
    <font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;Damping constant&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_Mechanics_Rotational_Types_InitRel.html#fbaa30c85551a040pes.InitRel.Temp"
>InitRel.Temp</A> initType=Modelica.Mechanics.Rotational.Types.InitRel.NoInit <font color="darkgreen">
    &quot;Type of initialization (defines usage of start values below)&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_rel_start=0 <font color="darkgreen">
    &quot;Initial or guess value of relative rotation angle phi_rel&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_rel_start=0 <font color="darkgreen">
    &quot;Initial or guess value of relative angular velocity w_rel = der(phi_rel)&quot;</font>;

  <font color="blue">parameter </font><A HREF="Modelica_Blocks_Types_StateSelection.html#f20e56826b4d9061teSelection.Temp"
>StateSelection.Temp</A> stateSelection=
            Modelica.Blocks.Types.StateSelection.Default <font color="darkgreen">
    &quot;Priority to use phi_rel and w_rel as states&quot;</font>;

  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#f545543dcc80f4b7rfaces.Compliant"
>Interfaces.Compliant</A>(phi_rel(start=phi_rel_start, stateSelect=
           <font color="blue">if </font>stateSelection==StateSelection.Never<font color="blue"> then </font>
              StateSelect.never<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Avoid<font color="blue"> then </font>
              StateSelect.avoid<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Default<font color="blue"> then </font>
              StateSelect.default<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Prefer<font color="blue"> then </font>
              StateSelect.prefer<font color="blue"> else </font>StateSelect.always));
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_rel(start=w_rel_start, stateSelect=
           <font color="blue">if </font>stateSelection==StateSelection.Never<font color="blue"> then </font>
              StateSelect.never<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Avoid<font color="blue"> then </font>
              StateSelect.avoid<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Default<font color="blue"> then </font>
              StateSelect.default<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Prefer<font color="blue"> then </font>
              StateSelect.prefer<font color="blue"> else </font>StateSelect.always) <font color="darkgreen">
    &quot;Relative angular velocity between flange_b and flange_a&quot;</font>;

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="blue">if </font>initType == InitRel.SteadyState<font color="blue"> then</font>
    <font color="red"> der</font>(phi_rel) = 0;
    <font color="red"> der</font>(w_rel)   = 0;
  <font color="blue">elseif </font>initType == InitRel.InitialState<font color="blue"> then</font>
     phi_rel = phi_rel_start;
     w_rel = w_rel_start;
  <font color="blue">elseif </font>initType == InitRel.InitialAngle<font color="blue"> then</font>
     phi_rel = phi_rel_start;
  <font color="blue">elseif </font>initType == InitRel.InitialSpeed<font color="blue"> then</font>
     w_rel = w_rel_start;
  <font color="blue">end if</font>;
<font color="blue">equation </font>
  w_rel =<font color="red"> der</font>(phi_rel);
  tau = c*(phi_rel - phi_rel0) + d*w_rel;
<font color="blue">end </font>SpringDamper;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE ElastoBacklash<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.ElastoBacklashI.png" ALT="Modelica.Mechanics.Rotational.ElastoBacklash" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="60da7067eeaeb788l.ElastoBacklash"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.ElastoBacklash</H2>
<B>Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.ElastoBacklashD.png" ALT="Modelica.Mechanics.Rotational.ElastoBacklash">
<H3>Information</H3>
<PRE></pre>
<p>
This element consists of a <b>backlash</b> element <b>connected in series</b>
to a <b>spring</b> and <b>damper</b> element which are <b>connected in parallel</b>.
The spring constant shall be non-zero, otherwise the component cannot be used.
</p>
<p>
In combination with components IdealGear, the ElastoBacklash model
can be used to model a gear box with backlash, elasticity and damping.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>b</TD><TD>0</TD><TD>Total backlash [rad]</TD></TR>
<TR><TD>Real</TD><TD>c</TD><TD>1.e5</TD><TD>Spring constant (c &gt; 0 required) [N.m/rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel0</TD><TD>0</TD><TD>Unstretched spring angle [rad]</TD></TR>
<TR><TD>Real</TD><TD>d</TD><TD>0</TD><TD>Damping constant [N.m.s/rad]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel.start</TD><TD>0</TD><TD>Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>(left) driving flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) driven flange (flange axis directed OUT OF cut plane)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> ElastoBacklash <font color="darkgreen">
  &quot;Backlash connected in series to linear spring and damper (backlash is modeled with elasticity)&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#f545543dcc80f4b7rfaces.Compliant"
>Interfaces.Compliant</A>;

  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> b(<font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;Total backlash&quot;</font>;
  <font color="blue">parameter </font>Real c(
    <font color="blue">final </font>unit=&quot;N.m/rad&quot;,
    <font color="blue">final </font>min=Modelica.Constants.small) = 1.e5 <font color="darkgreen">
    &quot;Spring constant (c &gt; 0 required)&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_rel0=0 <font color="darkgreen">&quot;Unstretched spring angle&quot;</font>;
  <font color="blue">parameter </font>Real d(
    <font color="blue">final </font>unit=&quot;N.m.s/rad&quot;,
    <font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;Damping constant&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_rel <font color="darkgreen">
    &quot;Relative angular velocity between flange_b and flange_a&quot;</font>;
<font color="blue">protected </font>
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> b2=b/2;
  <font color="darkgreen">// A minimum backlash is defined in order to avoid an infinite</font>
  <font color="darkgreen">// number of state events if backlash b is set to zero.</font>
  <font color="blue">constant </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> b_min=1.e-10 <font color="darkgreen">&quot;minimum backlash&quot;</font>;
<font color="blue">equation </font>
  w_rel =<font color="red"> der</font>(phi_rel);
  tau = <font color="blue">if </font>b2 &gt; b_min<font color="blue"> then </font>(<font color="blue">if </font>phi_rel &gt; b2<font color="blue"> then </font>c*(phi_rel - phi_rel0 - b2)
     + d*w_rel<font color="blue"> else </font>(<font color="blue">if </font>phi_rel &lt; -b2<font color="blue"> then </font>c*(phi_rel - phi_rel0 + b2) + d*
    w_rel<font color="blue"> else </font>0))<font color="blue"> else </font>c*(phi_rel - phi_rel0) + d*w_rel;
<font color="blue">end </font>ElastoBacklash;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE BearingFriction<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.BearingFrictionI.png" ALT="Modelica.Mechanics.Rotational.BearingFriction" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="3853572291d81c7f.BearingFriction"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.BearingFriction</H2>
<B>Coulomb friction in bearings </B><p>
<IMG SRC="Modelica.Mechanics.Rotational.BearingFrictionD.png" ALT="Modelica.Mechanics.Rotational.BearingFriction">
<H3>Information</H3>
<PRE></pre>
<p>
This element describes <b>Coulomb friction</b> in <b>bearings</b>,
i.e., a frictional torque acting between a flange and the housing.
The positive sliding friction torque "tau" has to be defined
by table "tau_pos" as function of the absolute angular velocity "w".
E.g.
<p>
<pre>
       w | tau
      ---+-----
       0 |   0
       1 |   2
       2 |   5
       3 |   8
</pre>
<p>
gives the following table:
</p>
<pre>
   tau_pos = [0, 0; 1, 2; 2, 5; 3, 8];
</pre>
<p>
Currently, only linear interpolation in the table is supported.
Outside of the table, extrapolation through the last
two table entries is used. It is assumed that the negative
sliding friction force has the same characteristic with negative
values. Friction is modelled in the following way:
</p>
<p>
When the absolute angular velocity "w" is not zero, the friction torque
is a function of w and of a constant normal force. This dependency
is defined via table tau_pos and can be determined by measurements,
e.g. by driving the gear with constant velocity and measuring the
needed motor torque (= friction torque).
</p>
<p>
When the absolute angular velocity becomes zero, the elements
connected by the friction element become stuck, i.e., the absolute
angle remains constant. In this phase the friction torque is
calculated from a torque balance due to the requirement, that
the absolute acceleration shall be zero.  The elements begin
to slide when the friction torque exceeds a threshold value,
called the maximum static friction torque, computed via:
</p>
<pre>
   maximum_static_friction = <b>peak</b> * sliding_friction(w=0)  (<b>peak</b> >= 1)
</pre>
<p>
This procedure is implemented in a "clean" way by state events and
leads to continuous/discrete systems of equations if friction elements
are dynamically coupled which have to be solved by appropriate
numerical methods. The method is described in:
</p>
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
<dd><b>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
</dl>
<p>
More precise friction models take into account the elasticity of the
material when the two elements are "stuck", as well as other effects,
like hysteresis. This has the advantage that the friction element can
be completely described by a differential equation without events. The
drawback is that the system becomes stiff (about 10-20 times slower
simulation) and that more material constants have to be supplied which
requires more sophisticated identification. For more details, see the
following references, especially (Armstrong and Canudas de Witt 1996):
</p>
<dl>
<dt>Armstrong B. (1991):
<dd><b>Control of Machines with Friction</b>. Kluwer Academic
    Press, Boston MA.<br><br>
<dt>Armstrong B., and Canudas de Wit C. (1996):
<dd><b>Friction Modeling and Compensation.</b>
    The Control Handbook, edited by W.S.Levine, CRC Press,
    pp. 1369-1382.<br><br>
<dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
<dd><b>A new model for control of systems with friction.</b>
    IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
</dl>


<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>tau_pos[:, :]</TD><TD>[0, 1]</TD><TD>[w,tau] Positive sliding friction characteristic (w&gt;=0)</TD></TR>
<TR><TD>Real</TD><TD>peak</TD><TD>1</TD><TD>peak*tau_pos[1,2] = Maximum friction torque for w==0</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD>Boolean</TD><TD>startForward.start</TD><TD><B>false</B></TD><TD>true, if w_rel=0 and start of forward sliding or w_rel &gt; w_small</TD></TR>
<TR><TD>Boolean</TD><TD>startBackward.start</TD><TD><B>false</B></TD><TD>true, if w_rel=0 and start of backward sliding or w_rel &lt; -w_small</TD></TR>
<TR><TD>Boolean</TD><TD>locked.start</TD><TD>false</TD><TD>true, if w_rel=0 and not sliding</TD></TR>
<TR bgcolor="#c0c0c0"><TD colspan=4><B>Advanced</B></TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_small</TD><TD>1e10</TD><TD>Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> BearingFriction <font color="darkgreen">&quot;Coulomb friction in bearings &quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#9883c0136ee2a6f8langesAndBearing"
>Interfaces.TwoFlangesAndBearing</A>;

  <font color="blue">parameter </font>Real tau_pos[:, :]=[0, 1] <font color="darkgreen">
    &quot;[w,tau] Positive sliding friction characteristic (w&gt;=0)&quot;</font>;
  <font color="blue">parameter </font>Real peak(<font color="blue">final </font>min=1) = 1 <font color="darkgreen">
    &quot;peak*tau_pos[1,2] = Maximum friction torque for w==0&quot;</font>;

  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#7cd766a564b5f185ces.FrictionBase"
>Interfaces.FrictionBase</A>;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w <font color="darkgreen">&quot;Absolute angular velocity of flange_a and flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a <font color="darkgreen">
    &quot;Absolute angular acceleration of flange_a and flange_b&quot;</font>;

<font color="blue">equation </font>
  <font color="darkgreen">// Constant auxiliary variables</font>
  tau0 =<font color="red"> Modelica.Math.tempInterpol1</font>(0, tau_pos, 2);
  tau0_max = peak*tau0;
  free = false;

  phi = phi_a;
  phi = phi_b;

  <font color="darkgreen">// Angular velocity and angular acceleration of flanges</font>
  w =<font color="red"> der</font>(phi);
  a =<font color="red"> der</font>(w);
  w_relfric = w;
  a_relfric = a;

  <font color="darkgreen">// Equilibrium of torques</font>
  0 = flange_a.tau + flange_b.tau - tau;

  <font color="darkgreen">// Friction torque</font>
  tau = <font color="blue">if </font>locked<font color="blue"> then </font>sa<font color="blue"> else </font>(<font color="blue">if </font>startForward<font color="blue"> then </font>
    <font color="red">Modelica.Math.tempInterpol1</font>(w, tau_pos, 2)<font color="blue"> else </font><font color="blue">if </font>startBackward<font color="blue"> then </font>-
    <font color="red">Modelica.Math.tempInterpol1</font>(-w, tau_pos, 2)<font color="blue"> else </font><font color="blue">if </font><font color="red">pre</font>(mode) == Forward<font color="blue"> then </font>
          <font color="red">Modelica.Math.tempInterpol1</font>(w, tau_pos, 2)<font color="blue"> else </font>-
    <font color="red">Modelica.Math.tempInterpol1</font>(-w, tau_pos, 2));
<font color="blue">end </font>BearingFriction;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Clutch<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.ClutchI.png" ALT="Modelica.Mechanics.Rotational.Clutch" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Clutch"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Clutch</H2>
<B>Clutch based on Coulomb friction </B><p>
<IMG SRC="Modelica.Mechanics.Rotational.ClutchD.png" ALT="Modelica.Mechanics.Rotational.Clutch">
<H3>Information</H3>
<PRE></pre>
<p>
This component models a <b>clutch</b>, i.e., a component with
two flanges where friction is present between the two flanges
and these flanges are pressed together via a normal force.
The normal force fn has to be provided as input signal f_normalized in a normalized form
(0 &le; f_normalized &le; 1),
fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the
clutch is modelled in the following way:
</p>
<p>
When the relative angular velocity is not zero, the friction torque is a
function of the velocity dependent friction coefficient  mue(w_rel) , of
the normal force "fn", and of a geometry constant "cgeo" which takes into
account the geometry of the device and the assumptions on the friction
distributions:
</p>
<pre>
        frictional_torque = <b>cgeo</b> * <b>mue</b>(w_rel) * <b>fn</b>
</pre>
<p>
   Typical values of coefficients of friction:
</p>
<pre>
      dry operation   :  <b>mue</b> = 0.2 .. 0.4
      operating in oil:  <b>mue</b> = 0.05 .. 0.1
</pre>
<p>
   When plates are pressed together, where  <b>ri</b>  is the inner radius,
   <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
   the geometry constant is calculated in the following way under the
   assumption of a uniform rate of wear at the interfaces:
</p>
<pre>
         <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
</pre>
<p>
    The positive part of the friction characteristic <b>mue</b>(w_rel),
    w_rel >= 0, is defined via table mue_pos (first column = w_rel,
    second column = mue). Currently, only linear interpolation in
    the table is supported.
</p>
<p>
   When the relative angular velocity becomes zero, the elements
   connected by the friction element become stuck, i.e., the relative
   angle remains constant. In this phase the friction torque is
   calculated from a torque balance due to the requirement, that
   the relative acceleration shall be zero.  The elements begin
   to slide when the friction torque exceeds a threshold value,
   called the  maximum static friction torque, computed via:
</p>
<pre>
       frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w_rel=0) * <b>fn</b>   (<b>peak</b> >= 1)
</pre>
<p>
This procedure is implemented in a "clean" way by state events and
leads to continuous/discrete systems of equations if friction elements
are dynamically coupled. The method is described in:
</p>
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
<dd><b>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
</dl>
<p>
More precise friction models take into account the elasticity of the
material when the two elements are "stuck", as well as other effects,
like hysteresis. This has the advantage that the friction element can
be completely described by a differential equation without events. The
drawback is that the system becomes stiff (about 10-20 times slower
simulation) and that more material constants have to be supplied which
requires more sophisticated identification. For more details, see the
following references, especially (Armstrong and Canudas de Witt 1996):
</p>
<dl>
<dt>Armstrong B. (1991):
<dd><b>Control of Machines with Friction</b>. Kluwer Academic
    Press, Boston MA.<br><br>
<dt>Armstrong B., and Canudas de Wit C. (1996):
<dd><b>Friction Modeling and Compensation.</b>
    The Control Handbook, edited by W.S.Levine, CRC Press,
    pp. 1369-1382.<br><br>
<dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
<dd><b>A new model for control of systems with friction.</b>
    IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
</dl>
<br>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>mue_pos[:, :]</TD><TD>[0, 0.5]</TD><TD>[w,mue] positive sliding friction coefficient (w_rel&gt;=0)</TD></TR>
<TR><TD>Real</TD><TD>peak</TD><TD>1</TD><TD>peak*mue_pos[1,2] = maximum value of mue for w_rel==0</TD></TR>
<TR><TD>Real</TD><TD>cgeo</TD><TD>1</TD><TD>Geometry constant containing friction distribution assumption</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>Force</A></TD><TD>fn_max</TD><TD>1</TD><TD>Maximum normal force [N]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel.start</TD><TD>0</TD><TD>Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</TD></TR>
<TR><TD>Boolean</TD><TD>startForward.start</TD><TD><B>false</B></TD><TD>true, if w_rel=0 and start of forward sliding or w_rel &gt; w_small</TD></TR>
<TR><TD>Boolean</TD><TD>startBackward.start</TD><TD><B>false</B></TD><TD>true, if w_rel=0 and start of backward sliding or w_rel &lt; -w_small</TD></TR>
<TR><TD>Boolean</TD><TD>locked.start</TD><TD>false</TD><TD>true, if w_rel=0 and not sliding</TD></TR>
<TR bgcolor="#c0c0c0"><TD colspan=4><B>Advanced</B></TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_small</TD><TD>1e10</TD><TD>Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>(left) driving flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) driven flange (flange axis directed OUT OF cut plane)</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>f_normalized</TD><TD>Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Clutch <font color="darkgreen">&quot;Clutch based on Coulomb friction &quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#f545543dcc80f4b7rfaces.Compliant"
>Interfaces.Compliant</A>;

  <font color="blue">parameter </font>Real mue_pos[:, :]=[0, 0.5] <font color="darkgreen">
    &quot;[w,mue] positive sliding friction coefficient (w_rel&gt;=0)&quot;</font>;
  <font color="blue">parameter </font>Real peak(<font color="blue">final </font>min=1) = 1 <font color="darkgreen">
    &quot;peak*mue_pos[1,2] = maximum value of mue for w_rel==0&quot;</font>;
  <font color="blue">parameter </font>Real cgeo(<font color="blue">final </font>min=0) = 1 <font color="darkgreen">
    &quot;Geometry constant containing friction distribution assumption&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>SI.Force</A> fn_max(<font color="blue">final </font>min=0) = 1 <font color="darkgreen">&quot;Maximum normal force&quot;</font>;

  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#7cd766a564b5f185ces.FrictionBase"
>Interfaces.FrictionBase</A>;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_rel <font color="darkgreen">
    &quot;Relative angular velocity (flange_b.w - flange_a.w)&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a_rel <font color="darkgreen">
    &quot;Relative angular acceleration (flange_b.a - flange_a.a)&quot;</font>;

  Real mue0 <font color="darkgreen">&quot;Friction coefficient for w=0 and forward sliding&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>SI.Force</A> fn <font color="darkgreen">&quot;Normal force (fn=fn_max*f_normalized)&quot;</font>;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> f_normalized <font color="darkgreen">
    &quot;Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)&quot;</font>;
<font color="blue">equation </font>
  <font color="darkgreen">// Constant auxiliary variable</font>
  mue0 =<font color="red"> Modelica.Math.tempInterpol1</font>(0, mue_pos, 2);

  <font color="darkgreen">// Relative quantities</font>
  w_rel =<font color="red"> der</font>(phi_rel);
  a_rel =<font color="red"> der</font>(w_rel);
  w_relfric = w_rel;
  a_relfric = a_rel;

  <font color="darkgreen">// Normal force and friction torque for w_rel=0</font>
  fn = fn_max*f_normalized;
  free = fn &lt;= 0;
  tau0 = mue0*cgeo*fn;
  tau0_max = peak*tau0;

  <font color="darkgreen">// friction torque</font>
  tau = <font color="blue">if </font>locked<font color="blue"> then </font>sa<font color="blue"> else </font><font color="blue">if </font>free<font color="blue"> then </font>0<font color="blue"> else </font>cgeo*fn*(<font color="blue">if </font>startForward<font color="blue"> then </font>
          <font color="red">Modelica.Math.tempInterpol1</font>(w_rel, mue_pos, 2)<font color="blue"> else </font><font color="blue">if </font>
    startBackward<font color="blue"> then </font>-<font color="red">Modelica.Math.tempInterpol1</font>(-w_rel, mue_pos, 2)<font color="blue"> else </font>
    <font color="blue">if </font><font color="red">pre</font>(mode) == Forward<font color="blue"> then </font><font color="red">Modelica.Math.tempInterpol1</font>(w_rel, mue_pos,
    2)<font color="blue"> else </font>-<font color="red">Modelica.Math.tempInterpol1</font>(-w_rel, mue_pos, 2));
<font color="blue">end </font>Clutch;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE OneWayClutch<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.OneWayClutchI.png" ALT="Modelica.Mechanics.Rotational.OneWayClutch" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="8b5343c0e7f072eanal.OneWayClutch"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.OneWayClutch</H2>
<B>Series connection of freewheel and clutch</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.OneWayClutchD.png" ALT="Modelica.Mechanics.Rotational.OneWayClutch">
<H3>Information</H3>
<PRE></pre>
<p>
This component models a <b>one-way clutch</b>, i.e., a component with
two flanges where friction is present between the two flanges
and these flanges are pressed together via a normal force. These
flanges maybe sliding with respect to each other
Parallel connection of ClutchCombi and of FreeWheel.
                     The element is introduced to resolve the ambiguity
                     of the constraint torques of the elements.
<p>
A one-way-clutch is an element where a clutch is connected in parallel
to a free wheel. This special element is provided, because such
a parallel connection introduces an ambiguity into the model
(the constraint torques are not uniquely defined when both
elements are stuck) and this element resolves it by introducing
<b>one</b> constraint torque and not two.
</p>
<p>
Note, initial values have to be chosen for the model, such that the
relative speed of the one-way-clutch >= 0. Otherwise, the configuration
is physically not possible and an error occurs.
</p>
<p>
The normal force fn has to be provided as input signal f_normalized in a normalized form
(0 &le; f_normalized &le; 1),
fn = fn_max*f_normalized, where fn_max has to be provided as parameter. Friction in the
clutch is modelled in the following way:
</p>
<p>
When the relative angular velocity is positive, the friction torque is a
function of the velocity dependent friction coefficient  mue(w_rel) , of
the normal force "fn", and of a geometry constant "cgeo" which takes into
account the geometry of the device and the assumptions on the friction
distributions:
</p>
<pre>
        frictional_torque = <b>cgeo</b> * <b>mue</b>(w_rel) * <b>fn</b>
</pre>
<p>
   Typical values of coefficients of friction:
</p>
<pre>
      dry operation   :  <b>mue</b> = 0.2 .. 0.4
      operating in oil:  <b>mue</b> = 0.05 .. 0.1
</pre>
<p>
   When plates are pressed together, where  <b>ri</b>  is the inner radius,
   <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
   the geometry constant is calculated in the following way under the
   assumption of a uniform rate of wear at the interfaces:
</p>
<pre>
         <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
</pre>
<p>
    The positive part of the friction characteristic <b>mue</b>(w_rel),
    w_rel >= 0, is defined via table mue_pos (first column = w_rel,
    second column = mue). Currently, only linear interpolation in
    the table is supported.
</p>
<p>
   When the relative angular velocity becomes zero, the elements
   connected by the friction element become stuck, i.e., the relative
   angle remains constant. In this phase the friction torque is
   calculated from a torque balance due to the requirement, that
   the relative acceleration shall be zero.  The elements begin
   to slide when the friction torque exceeds a threshold value,
   called the  maximum static friction torque, computed via:
</p>
<pre>
       frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w_rel=0) * <b>fn</b>   (<b>peak</b> >= 1)
</pre>
<p>
This procedure is implemented in a "clean" way by state events and
leads to continuous/discrete systems of equations if friction elements
are dynamically coupled. The method is described in:
</p>
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
<dd><b>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
</dl>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>mue_pos[:, :]</TD><TD>[0, 0.5]</TD><TD>[w,mue] positive sliding friction coefficient (w_rel&gt;=0)</TD></TR>
<TR><TD>Real</TD><TD>peak</TD><TD>1</TD><TD>peak*mue_pos[1,2] = maximum value of mue for w_rel==0</TD></TR>
<TR><TD>Real</TD><TD>cgeo</TD><TD>1</TD><TD>Geometry constant containing friction distribution assumption</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>Force</A></TD><TD>fn_max</TD><TD>1</TD><TD>Maximum normal force [N]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_rel.start</TD><TD>0</TD><TD>Relative rotation angle (= flange_b.phi - flange_a.phi) [rad]</TD></TR>
<TR bgcolor="#c0c0c0"><TD colspan=4><B>Advanced</B></TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_small</TD><TD>1e10</TD><TD>Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>(left) driving flange (flange axis directed INTO cut plane)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) driven flange (flange axis directed OUT OF cut plane)</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>f_normalized</TD><TD>Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> OneWayClutch <font color="darkgreen">&quot;Series connection of freewheel and clutch&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#f545543dcc80f4b7rfaces.Compliant"
>Interfaces.Compliant</A>;

  <font color="blue">parameter </font>Real mue_pos[:, :]=[0, 0.5] <font color="darkgreen">
    &quot;[w,mue] positive sliding friction coefficient (w_rel&gt;=0)&quot;</font>;
  <font color="blue">parameter </font>Real peak(<font color="blue">final </font>min=1) = 1 <font color="darkgreen">
    &quot;peak*mue_pos[1,2] = maximum value of mue for w_rel==0&quot;</font>;
  <font color="blue">parameter </font>Real cgeo(<font color="blue">final </font>min=0) = 1 <font color="darkgreen">
    &quot;Geometry constant containing friction distribution assumption&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>SI.Force</A> fn_max(<font color="blue">final </font>min=0) = 1 <font color="darkgreen">&quot;Maximum normal force&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_small=1e10 <font color="darkgreen">
    &quot;Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur)&quot;</font>;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_rel <font color="darkgreen">
    &quot;Relative angular velocity (flange_b.w - flange_a.w)&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a_rel <font color="darkgreen">
    &quot;Relative angular acceleration (flange_b.a - flange_a.a)&quot;</font>;
  Real u <font color="darkgreen">&quot;normalized force input signal (0..1)&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>SI.Force</A> fn <font color="darkgreen">&quot;Normal force (fn=fn_max*inPort.signal)&quot;</font>;
  Boolean startForward <font color="darkgreen">
    &quot;true, if w_rel=0 and start of forward sliding or w_rel &gt; w_small&quot;</font>;
  Boolean locked <font color="darkgreen">&quot;true, if w_rel=0 and not sliding&quot;</font>;
  Boolean stuck(<font color="blue">final </font>start=false) <font color="darkgreen">&quot;w_rel=0 (forward sliding or locked)&quot;</font>;

<font color="blue">protected </font>
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau0 <font color="darkgreen">&quot;Friction torque for w=0 and sliding&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau0_max <font color="darkgreen">&quot;Maximum friction torque for w=0 and locked&quot;</font>;
  Real mue0 <font color="darkgreen">&quot;Friction coefficient for w=0 and sliding&quot;</font>;
  Boolean free <font color="darkgreen">&quot;true, if frictional element is not active&quot;</font>;
  Real sa <font color="darkgreen">&quot;path parameter of tau = f(a_rel) Friction characteristic&quot;</font>;
  <font color="blue">constant </font>Real eps0=1.0e-4 <font color="darkgreen">&quot;Relative hysteresis epsilon&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau0_max_low <font color="darkgreen">&quot;lowest value for tau0_max&quot;</font>;
  <font color="blue">parameter </font>Real peak2=<font color="red">max</font>([peak, 1 + eps0]);
  <font color="blue">constant </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> unitAngularAcceleration = 1;
  <font color="blue">constant </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> unitTorque = 1;
<font color="blue">public </font>
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> f_normalized <font color="darkgreen">
    &quot;Normalized force signal 0..1 (normal force = fn_max*f_normalized; clutch is engaged if &gt; 0)&quot;</font>;
<font color="blue">equation </font>
  <font color="darkgreen">// Constant auxiliary variable</font>
  mue0 =<font color="red"> Modelica.Math.tempInterpol1</font>(0, mue_pos, 2);
  tau0_max_low = eps0*mue0*cgeo*fn_max;

  <font color="darkgreen">// Relative quantities</font>
  w_rel =<font color="red"> der</font>(phi_rel);
  a_rel =<font color="red"> der</font>(w_rel);

  <font color="darkgreen">// Normal force and friction torque for w_rel=0</font>
  u = f_normalized;
  free = u &lt;= 0;
  fn = <font color="blue">if </font>free<font color="blue"> then </font>0<font color="blue"> else </font>fn_max*u;
  tau0 = mue0*cgeo*fn;
  tau0_max = <font color="blue">if </font>free<font color="blue"> then </font>tau0_max_low<font color="blue"> else </font>peak2*tau0;

  <font color="darkgreen">/* Friction characteristic
       (locked is introduced to help the Modelica translator determining
       the different structural configurations, if for each configuration
       special code shall be generated)
    */</font>
  startForward =<font color="red"> pre</font>(stuck)<font color="blue"> and </font>(sa &gt; tau0_max<font color="blue"> or </font><font color="red">pre</font>(startForward)<font color="blue"> and </font>sa &gt;
    tau0<font color="blue"> or </font>w_rel &gt; w_small)<font color="blue"> or </font><font color="red">initial</font>()<font color="blue"> and </font>(w_rel &gt; 0);
  locked =<font color="red"> pre</font>(stuck)<font color="blue"> and </font><font color="blue">not </font>startForward;

  <font color="darkgreen">// acceleration and friction torque</font>
  a_rel = unitAngularAcceleration* (<font color="blue">if </font>locked<font color="blue"> then </font>0<font color="blue"> else </font>sa - tau0/unitTorque);
  tau = <font color="blue">if </font>locked<font color="blue"> then </font>sa<font color="blue"> else </font>(<font color="blue">if </font>free<font color="blue"> then </font>0<font color="blue"> else </font>cgeo*fn*
    <font color="red">Modelica.Math.tempInterpol1</font>(w_rel, mue_pos, 2));

  <font color="darkgreen">// Determine configuration</font>
  stuck = locked<font color="blue"> or </font>w_rel &lt;= 0;
<font color="blue">end </font>OneWayClutch;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Brake<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.BrakeI.png" ALT="Modelica.Mechanics.Rotational.Brake" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Brake"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Brake</H2>
<B>Brake based on Coulomb friction </B><p>
<IMG SRC="Modelica.Mechanics.Rotational.BrakeD.png" ALT="Modelica.Mechanics.Rotational.Brake">
<H3>Information</H3>
<PRE></pre>
<p>
This component models a <b>brake</b>, i.e., a component where a frictional
torque is acting between the housing and a flange and a controlled normal
force presses the flange to the housing in order to increase friction.
The normal force fn has to be provided as input signal f_normalized in a normalized form
(0 &le; f_normalized &le; 1),
fn = fn_max*f_normalized, where fn_max has to be provided as parameter.
Friction in the brake is modelled in the following way:
</p>
<p>
When the absolute angular velocity "w" is not zero, the friction torque
is a function of the velocity dependent friction coefficient  mue(w) , of
the normal force "fn", and of a geometry constant "cgeo" which takes into
account the geometry of the device and the assumptions on the friction
distributions:
</p>
<pre>
        frictional_torque = <b>cgeo</b> * <b>mue</b>(w) * <b>fn</b>
</pre>
<p>
   Typical values of coefficients of friction:
</p>
<pre>
      dry operation   :  <b>mue</b> = 0.2 .. 0.4
      operating in oil:  <b>mue</b> = 0.05 .. 0.1
</pre>
<p>
   When plates are pressed together, where  <b>ri</b>  is the inner radius,
   <b>ro</b> is the outer radius and <b>N</b> is the number of friction interfaces,
   the geometry constant is calculated in the following way under the
   assumption of a uniform rate of wear at the interfaces:
</p>
<pre>
         <b>cgeo</b> = <b>N</b>*(<b>r0</b> + <b>ri</b>)/2
</pre>
<p>
    The positive part of the friction characteristic <b>mue</b>(w),
    w >= 0, is defined via table mue_pos (first column = w,
    second column = mue). Currently, only linear interpolation in
    the table is supported.
</p>
<p>
   When the absolute angular velocity becomes zero, the elements
   connected by the friction element become stuck, i.e., the absolute
   angle remains constant. In this phase the friction torque is
   calculated from a torque balance due to the requirement, that
   the absolute acceleration shall be zero.  The elements begin
   to slide when the friction torque exceeds a threshold value,
   called the  maximum static friction torque, computed via:
</p>
<pre>
       frictional_torque = <b>peak</b> * <b>cgeo</b> * <b>mue</b>(w=0) * <b>fn</b>   (<b>peak</b> >= 1)
</pre>
<p>
This procedure is implemented in a "clean" way by state events and
leads to continuous/discrete systems of equations if friction elements
are dynamically coupled. The method is described in:
</p>
<dl>
<dt>Otter M., Elmqvist H., and Mattsson S.E. (1999):
<dd><b>Hybrid Modeling in Modelica based on the Synchronous
    Data Flow Principle</b>. CACSD'99, Aug. 22.-26, Hawaii.
</dl>
<p>
More precise friction models take into account the elasticity of the
material when the two elements are "stuck", as well as other effects,
like hysteresis. This has the advantage that the friction element can
be completely described by a differential equation without events. The
drawback is that the system becomes stiff (about 10-20 times slower
simulation) and that more material constants have to be supplied which
requires more sophisticated identification. For more details, see the
following references, especially (Armstrong and Canudas de Witt 1996):
</p>
<dl>
<dt>Armstrong B. (1991):
<dd><b>Control of Machines with Friction</b>. Kluwer Academic
    Press, Boston MA.<br><br>
<dt>Armstrong B., and Canudas de Wit C. (1996):
<dd><b>Friction Modeling and Compensation.</b>
    The Control Handbook, edited by W.S.Levine, CRC Press,
    pp. 1369-1382.<br><br>
<dt>Canudas de Wit C., Olsson H., Astroem K.J., and Lischinsky P. (1995):
<dd><b>A new model for control of systems with friction.</b>
    IEEE Transactions on Automatic Control, Vol. 40, No. 3, pp. 419-425.<br><br>
</dl>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>mue_pos[:, :]</TD><TD>[0, 0.5]</TD><TD>[w,mue] positive sliding friction coefficient (w_rel&gt;=0)</TD></TR>
<TR><TD>Real</TD><TD>peak</TD><TD>1</TD><TD>peak*mue_pos[1,2] = maximum value of mue for w_rel==0</TD></TR>
<TR><TD>Real</TD><TD>cgeo</TD><TD>1</TD><TD>Geometry constant containing friction distribution assumption</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>Force</A></TD><TD>fn_max</TD><TD>1</TD><TD>Maximum normal force [N]</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</TD></TR>
<TR><TD>Boolean</TD><TD>startForward.start</TD><TD><B>false</B></TD><TD>true, if w_rel=0 and start of forward sliding or w_rel &gt; w_small</TD></TR>
<TR><TD>Boolean</TD><TD>startBackward.start</TD><TD><B>false</B></TD><TD>true, if w_rel=0 and start of backward sliding or w_rel &lt; -w_small</TD></TR>
<TR><TD>Boolean</TD><TD>locked.start</TD><TD>false</TD><TD>true, if w_rel=0 and not sliding</TD></TR>
<TR bgcolor="#c0c0c0"><TD colspan=4><B>Advanced</B></TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_small</TD><TD>1e10</TD><TD>Relative angular velocity near to zero if jumps due to a reinit(..) of the velocity can occur (set to low value only if such impulses can occur) [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>f_normalized</TD><TD>Normalized force signal 0..1 (normal force = fn_max*f_normalized; brake is active if &gt; 0)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Brake <font color="darkgreen">&quot;Brake based on Coulomb friction &quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#9883c0136ee2a6f8langesAndBearing"
>Interfaces.TwoFlangesAndBearing</A>;

  <font color="blue">parameter </font>Real mue_pos[:, :]=[0, 0.5] <font color="darkgreen">
    &quot;[w,mue] positive sliding friction coefficient (w_rel&gt;=0)&quot;</font>;
  <font color="blue">parameter </font>Real peak(<font color="blue">final </font>min=1) = 1 <font color="darkgreen">
    &quot;peak*mue_pos[1,2] = maximum value of mue for w_rel==0&quot;</font>;
  <font color="blue">parameter </font>Real cgeo(<font color="blue">final </font>min=0) = 1 <font color="darkgreen">
    &quot;Geometry constant containing friction distribution assumption&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>SI.Force</A> fn_max(<font color="blue">final </font>min=0) = 1 <font color="darkgreen">&quot;Maximum normal force&quot;</font>;

  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#7cd766a564b5f185ces.FrictionBase"
>Interfaces.FrictionBase</A>;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w <font color="darkgreen">&quot;Absolute angular velocity of flange_a and flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a <font color="darkgreen">
    &quot;Absolute angular acceleration of flange_a and flange_b&quot;</font>;

  Real mue0 <font color="darkgreen">&quot;Friction coefficient for w=0 and forward sliding&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Force"
>SI.Force</A> fn <font color="darkgreen">&quot;Normal force (=fn_max*f_normalized)&quot;</font>;

  <font color="darkgreen">// Constant auxiliary variable</font>
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> f_normalized <font color="darkgreen">
    &quot;Normalized force signal 0..1 (normal force = fn_max*f_normalized; brake is active if &gt; 0)&quot;</font>;
<font color="blue">equation </font>
  mue0 =<font color="red"> Modelica.Math.tempInterpol1</font>(0, mue_pos, 2);

  phi = phi_a;
  phi = phi_b;

  <font color="darkgreen">  // Angular velocity and angular acceleration of flanges flange_a and flange_b</font>
  w =<font color="red"> der</font>(phi);
  a =<font color="red"> der</font>(w);
  w_relfric = w;
  a_relfric = a;

  <font color="darkgreen">// Torque equilibrium, normal force and friction torque for w_rel=0</font>
  0 = flange_a.tau + flange_b.tau - tau;
  fn = fn_max*f_normalized;
  tau0 = mue0*cgeo*fn;
  tau0_max = peak*tau0;
  free = fn &lt;= 0;

  <font color="darkgreen">// friction torque</font>
  tau = <font color="blue">if </font>locked<font color="blue"> then </font>sa<font color="blue"> else </font><font color="blue">if </font>free<font color="blue"> then </font>0<font color="blue"> else </font>cgeo*fn*(<font color="blue">if </font>startForward<font color="blue"> then </font>
          <font color="red">Modelica.Math.tempInterpol1</font>(w, mue_pos, 2)<font color="blue"> else </font><font color="blue">if </font>startBackward<font color="blue"> then </font>
          -<font color="red">Modelica.Math.tempInterpol1</font>(-w, mue_pos, 2)<font color="blue"> else </font><font color="blue">if </font><font color="red">pre</font>(mode) ==
    Forward<font color="blue"> then </font><font color="red">Modelica.Math.tempInterpol1</font>(w, mue_pos, 2)<font color="blue"> else </font>-
    <font color="red">Modelica.Math.tempInterpol1</font>(-w, mue_pos, 2));
<font color="blue">end </font>Brake;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LossyGear<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.LossyGearI.png" ALT="Modelica.Mechanics.Rotational.LossyGear" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="ce8c5f7b945a5521tional.LossyGear"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.LossyGear</H2>
<B>Gear with mesh efficiency and bearing friction (stuck/rolling possible)</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.LossyGearD.png" ALT="Modelica.Mechanics.Rotational.LossyGear">
<H3>Information</H3>
<PRE></pre>
<p>
This component models the gear ratio and the <b>losses</b> of
a standard gear box in a <b>reliable</b> way including the stuck phases
that may occur at zero speed. The gear boxes that can
be handeled are fixed in the ground, have one input and one
output shaft, and are essentially described by the equations:
</p>
<pre>     flange_a.phi  = i*flange_b.phi
   (-flange_b.tau) = i*(eta_mf*flange_a.tau - tau_bf)
</pre>
<p>
where
</p>
<ul>
<li><b>i</b> is the constant <b>gear ratio</b>,</li>
<li><b>eta_mf</b> = eta_mf(w) is the <b>mesh efficiency</b> due to the
   friction between the teeth of the gear wheels, </li>
<li><b>tau_bf</b> = tau_bf(w) is the <b>bearing friction torque</b>, and</li>
<li><b>w_a</b> = der(flange_a.phi) is the speed of flange_a</li>
</ul>
<p>The loss terms "eta_mf" and "tau_bf" are functions of the
<i>absolute value</i> of the input shaft speed w_a and of the energy
flow direction. They are defined by parameter <b>lossTable[:,5]
</b> where the columns of this table have the following
meaning:</p>
<p><table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign="top">|w_a|</td>
      <td valign="top">eta_mf1</td>
      <td valign="top">eta_mf2</td>
      <td valign="top">|tau_bf1|</td>
      <td valign="top">|tau_bf2|</td>
    </tr>
    <tr>
      <td align="center">...</td>
      <td align="center">...</td>
      <td align="center">...</td>
      <td align="center">...</td>
      <td align="center">...</td>
    </tr>
    <tr>
      <td align="center">...</td>
      <td align="center">...</td>
      <td align="center">...</td>
      <td align="center">...</td>
      <td align="center">...</td>
    </tr>
  </tbody>
</table></p>
<p>with</p>
<p><table BORDER=1 CELLSPACING=0 CELLPADDING=2>
  <tbody>
    <tr>
      <td valign="top">|w_a|</td>
      <td valign="top">Absolute value of angular velocity of input shaft flange_a</td>
    </tr>
    <tr>
      <td valign="top">eta_mf1</td>
      <td valign="top">Mesh efficiency in case of input shaft driving</td>
    </tr>
    <tr>
      <td valign="top">eta_mf2</td>
      <td valign="top">Mesh efficiency in case of output shaft driving</td>
    </tr>
    <tr>
      <td valign="top">|tau_bf1|</td>
      <td valign="top">Absolute bearing friction torque in case of input shaft driving</td>
    </tr>
    <tr>
      <td valign="top">|tau_bf2|</td>
      <td valign="top">Absolute bearing friction torque in case of output shaft driving</td>
    </tr>
  </tbody>
</table></p>
<p>
With these variables, the mesh efficiency and the bearing friction
are formally defined as:
</p>
<pre>  <b>if</b> flange_a.tau*w_a > 0 <b>or</b> flange_a.tau==0 <b>and</b> w_a > 0 <b>then</b>
     eta_mf := eta_mf1
     tau_bf := tau_bf1
  <b>elseif</b> flange_a.tau*w_a &lt; 0 <b>or</b> flange_a.tau==0 <b>and</b> w_a &lt; 0 <b>then</b>
     eta_mf := 1/eta_mf2
     tau_bf := tau_bf2
  <b>else</b> // w_a == 0
     eta_mf and tau_bf are computed such that <b>der</b>(w_a) = 0
  <b>end if</b>;
</pre>
<p>Note, that the losses are modeled in a physically meaningful way taking
into account that at zero speed the movement may be locked due
to the friction in the gear teeth and/or in the bearings.
Due to this important property, this component can be used in
situations where the combination of the components
Modelica.Mechanics.Rotational.IdealGear and
Modelica.Mechanics.Rotational.GearEfficiency will fail because,
e.g., chattering occurs when using the
Modelica.Mechanics.Rotational.GearEfficiency model.
</p>
<p>
<b>Acknowledgement:</b> The essential idea to model efficiency
in this way is from Christoph Pelchen, ZF Friedrichshafen.
</p>
<p><b>For detailed information:</b></p>
<p>Pelchen C.,
<a href="http://www.robotic.dlr.de/Christian.Schweiger/">Schweiger C.</a>,
and <a href="http://www.robotic.dlr.de/Martin.Otter/">Otter M.</a>:
&quot;<a href="http://www.modelica.org/Conference2002/papers/p33_Pelchen.pdf">Modeling
and Simulating the Efficiency of Gearboxes and of Planetary Gearboxes</A>,&quot; in
<I>Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany,</I>
pp. 257-266, The Modelica Association and Institute of Robotics and Mechatronics,
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e. V., March 18-19, 2002.</p>
<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>i</TD><TD>1</TD><TD>Transmission ratio (flange_a.phi/flange_b.phi)</TD></TR>
<TR><TD>Real</TD><TD>lossTable[:, 5]</TD><TD>[0, 1, 1, 0, 0]</TD><TD>Array for mesh efficiencies and bearing friction depending on speed</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> LossyGear <font color="darkgreen">
  &quot;Gear with mesh efficiency and bearing friction (stuck/rolling possible)&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#9883c0136ee2a6f8langesAndBearing"
>Interfaces.TwoFlangesAndBearing</A>;

  <font color="blue">parameter </font>Real i=1 <font color="darkgreen">&quot;Transmission ratio (flange_a.phi/flange_b.phi)&quot;</font>;
  <font color="blue">parameter </font>Real lossTable[:, 5]=[0, 1, 1, 0, 0] <font color="darkgreen">
    &quot;Array for mesh efficiencies and bearing friction depending on speed&quot;</font>;

  Real sa <font color="darkgreen">&quot;path parameter for acceleration and torque loss&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_a <font color="darkgreen">&quot;angular velocity of flange_a&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a_a <font color="darkgreen">&quot;angular acceleration of flange_a&quot;</font>;

  Real interpolation_result[1,<font color="red"> size</font>(lossTable, 2) - 1];
  Real eta_mf1;
  Real eta_mf2;
  Real tau_bf1;
  Real tau_bf2;

  Real quadrant1;
  Real quadrant2;
  Real quadrant3;
  Real quadrant4;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tauLoss <font color="darkgreen">
    &quot;Torque loss due to friction in the gear teeth and in the bearings&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tauLossMax <font color="darkgreen">&quot;Torque loss for positive speed&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tauLossMin <font color="darkgreen">&quot;Torque loss for negative speed&quot;</font>;

  Boolean tau_aPos <font color="darkgreen">&quot;true, if torque of flange_a is not negative&quot;</font>;
  Boolean startForward <font color="darkgreen">&quot;true, if starting to roll forward&quot;</font>;
  Boolean startBackward <font color="darkgreen">&quot;true, if starting to roll backward&quot;</font>;
  Boolean locked <font color="darkgreen">&quot;true, if gear is locked&quot;</font>;

  Boolean ideal <font color="darkgreen">&quot;true, if losses are neglected&quot;</font>;

  <font color="blue">constant </font>Integer Unknown=3 <font color="darkgreen">&quot;Value of mode is not known&quot;</font>;
  <font color="blue">constant </font>Integer Free=2 <font color="darkgreen">&quot;Element is not active&quot;</font>;
  <font color="blue">constant </font>Integer Forward=1 <font color="darkgreen">&quot;w_a &gt; 0 (forward rolling)&quot;</font>;
  <font color="blue">constant </font>Integer Stuck=0 <font color="darkgreen">
    &quot;w_a = 0 (forward rolling, locked or backward rolling)&quot;</font>;
  <font color="blue">constant </font>Integer Backward=-1 <font color="darkgreen">&quot;w_a &lt; 0 (backward rolling)&quot;</font>;
  Integer mode(
    <font color="blue">final </font>min=Backward,
    <font color="blue">final </font>max=Unknown,
    start=Free,
    fixed=true);


<font color="blue">protected </font>
  <font color="blue">constant </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> unitAngularAcceleration = 1;
  <font color="blue">constant </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> unitTorque = 1;
  <font color="blue">function</font> equal <font color="darkgreen">&quot;Compare whether two Real matrices are identical&quot;</font>

    <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
    <font color="blue">input </font>Real A[:, :];
    <font color="blue">input </font>Real B[:, :];
    <font color="blue">input </font>Real eps=Modelica.Constants.eps <font color="darkgreen">
      &quot;two numbers r1, r2 are identical if abs(r1-r2) &lt;= eps&quot;</font>;
    <font color="blue">output </font>Boolean result;
  <font color="blue">algorithm </font>
    result := false;
    <font color="blue">if </font><font color="red">size</font>(A, 1) == <font color="red">size</font>(B, 1)<font color="blue"> and </font><font color="red">size</font>(A, 2) == <font color="red">size</font>(B, 2)<font color="blue"> then</font>
      result := true;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 1)<font color="blue"> loop</font>
        <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(A, 2)<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">abs</font>(A[i, j] - B[i, j]) &gt;= eps<font color="blue"> then</font>
            result := false;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;
  <font color="blue">end </font>equal;
<font color="blue">equation </font>

  <font color="red">assert</font>(<font color="red">abs</font>(i) &gt; 0,
    &quot;Error in initialization of LossyGear: i may not be zero&quot;);

  ideal =<font color="red"> equal</font>(lossTable, [0, 1, 1, 0, 0]);

  interpolation_result = <font color="blue">if </font>ideal<font color="blue"> then </font>[1, 1, 0, 0]<font color="blue"> else </font>
    <font color="red">Modelica.Math.tempInterpol2</font>(<font color="red">noEvent</font>(<font color="red">abs</font>(w_a)), lossTable, {2,3,4,5});
  eta_mf1 = interpolation_result[1, 1];
  eta_mf2 = interpolation_result[1, 2];
  tau_bf1 =<font color="red"> noEvent</font>(<font color="red">abs</font>(interpolation_result[1, 3]));
  tau_bf2 =<font color="red"> noEvent</font>(<font color="red">abs</font>(interpolation_result[1, 4]));

  phi_a = i*phi_b;

  <font color="darkgreen">// Torque balance (no inertias)</font>
  0 = flange_b.tau + i*(flange_a.tau - tauLoss);

  <font color="darkgreen">// Speed for friction element</font>
  w_a =<font color="red"> der</font>(phi_a);
  a_a =<font color="red"> der</font>(w_a);

  quadrant1 = (1 - eta_mf1)*flange_a.tau + tau_bf1;
  quadrant2 = (1 - 1/eta_mf2)*flange_a.tau + tau_bf2;
  quadrant4 = (1 - 1/eta_mf2)*flange_a.tau - tau_bf2;
  quadrant3 = (1 - eta_mf1)*flange_a.tau - tau_bf1;

  <font color="darkgreen">// Torque Losses</font>
  tau_aPos = ideal<font color="blue"> or </font>(flange_a.tau &gt;= 0);
  tauLossMax = <font color="blue">if </font>tau_aPos<font color="blue"> then </font>quadrant1<font color="blue"> else </font>quadrant2;
  tauLossMin = <font color="blue">if </font>tau_aPos<font color="blue"> then </font>quadrant4<font color="blue"> else </font>quadrant3;

  <font color="darkgreen">// Determine rolling/stuck mode when w_rel = 0</font>
  startForward =<font color="red"> pre</font>(mode) == Stuck<font color="blue"> and </font>sa &gt; tauLossMax<font color="blue"> or </font><font color="red">initial</font>()<font color="blue"> and </font>w_a
     &gt; 0;
  startBackward =<font color="red"> pre</font>(mode) == Stuck<font color="blue"> and </font>sa &lt; tauLossMin<font color="blue"> or </font><font color="red">initial</font>()<font color="blue"> and </font>w_a
     &lt; 0;
  locked = <font color="blue">not </font>(ideal<font color="blue"> or </font><font color="red">pre</font>(mode) == Forward<font color="blue"> or </font>startForward<font color="blue"> or </font><font color="red">pre</font>(mode)
     == Backward<font color="blue"> or </font>startBackward);

  <font color="darkgreen">/* Parameterized curve description a_a = f1(sa), tauLoss = f2(sa)
       In comparison to Modelica.Mechanics.Rotational.FrictionBase it is possible
       to simplify the following expression as mode == Stuck is assured in case
       of startForward or startBackward */</font>
  tauLoss = <font color="blue">if </font>ideal<font color="blue"> then </font>0<font color="blue"> else </font>(<font color="blue">if </font>locked<font color="blue"> then </font>sa<font color="blue"> else </font>(<font color="blue">if </font>(startForward<font color="blue"> or </font>
        <font color="red">pre</font>(mode) == Forward)<font color="blue"> then </font>tauLossMax<font color="blue"> else </font>tauLossMin));

  a_a = unitAngularAcceleration*(<font color="blue">if </font>locked<font color="blue"> then </font>0<font color="blue"> else </font>sa - tauLoss/unitTorque);

  <font color="darkgreen">/* Finite state machine to fix configuration after the computation above
       The above equations are only dependent on pre(mode) and not on the actual
       value of mode. This prevents loops. So mode can be determined in one step. */</font>
  mode = <font color="blue">if </font>ideal<font color="blue"> then </font>Free<font color="blue"> else </font>(<font color="blue">if </font>(<font color="red">pre</font>(mode) == Forward<font color="blue"> or </font>startForward)<font color="blue">
     and </font>w_a &gt; 0<font color="blue"> then </font>Forward<font color="blue"> else </font><font color="blue">if </font>(<font color="red">pre</font>(mode) == Backward<font color="blue"> or </font>startBackward)<font color="blue">
     and </font>w_a &lt; 0<font color="blue"> then </font>Backward<font color="blue"> else </font>Stuck);
<font color="blue">end </font>LossyGear;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE GearEfficiency<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.GearEfficiencyI.png" ALT="Modelica.Mechanics.Rotational.GearEfficiency" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="e3b7edc27e8821bfl.GearEfficiency"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.GearEfficiency</H2>
<B>Obsolete component (use model LossyGear instead)</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.GearEfficiencyD.png" ALT="Modelica.Mechanics.Rotational.GearEfficiency">
<H3>Information</H3>
<PRE></pre>
<p>
THIS COMPONENT IS <b>OBSOLETE</b> and should <b>no longer be used</b>. It is only
kept for <b>backward compatibility</b> purposes. Use model
Modelica.Mechanics.Rotational.LossyGear instead which implements
gear efficiency in a much more reliable way.
</p>
<p>
This component consists of two rigidly connected flanges flange_a and flange_b without
inertia where an <b>efficency</b> coefficient <b>eta</b> reduces the driven
torque as function of the driving torque depending on the direction
of the energy flow, i.e., energy is always lost. This can be seen as a
simple model of the Coulomb friction acting between the teeth of a
gearbox.
</p>
<p>
Note, that most gearbox manufacturers provide tables of the
efficiency of a gearbox as function of the angular velocity
(efficiency becomes zero, if the angular velocity is zero).
However, such a table is practically useless for simulation purposes,
because in gearboxes always two types of friction is present:
(1) Friction in the <b>bearings</b> and (2) friction between
the teeth of the gear. (1) leads to a velocity dependent, additive
loss-torque, whereas (2) leads to a torque-dependent reduction of the
driving torque. The gearbox manufacturers measure both effects
together and determine the gear efficiency from it, although for
simulation purposes the two effects need to be separated.
Assume for example that only constant bearing friction, i.e.,
bearingTorque=const., is present, i.e.,
</p>
<pre>
   (1)  loadTorque = motorTorque - sign(w)*bearingTorque
</pre>
<p>
Gearbox manufacturers use the loss-formula
</p>
<pre>
   (2)  loadTorque = eta*motorTorque
</pre>
<p>
Comparing (1) and (2) gives a formulat for the efficiency eta:
</p>
<pre>
   eta = (1 - sign(w)*bearingTorque/motorTorque)
</pre>
<p>
When the motorTorque becomes smaller as the bearingTorque,
(2) is useless, because the efficiency is zero. To summarize,
be careful to determine the gear <b>efficiency</b> of this element
from tables of the gear manufacturers.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>eta</TD><TD>1</TD><TD>Efficiency</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> GearEfficiency <font color="darkgreen">
  &quot;Obsolete component (use model LossyGear instead)&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#9883c0136ee2a6f8langesAndBearing"
>Interfaces.TwoFlangesAndBearing</A>;

  <font color="blue">parameter </font>Real eta(
    min=Modelica.Constants.small,
    max=1) = 1 <font color="darkgreen">&quot;Efficiency&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Power"
>SI.Power</A> power_a <font color="darkgreen">&quot;Energy flowing into flange_a (= power)&quot;</font>;
  Boolean driving_a <font color="darkgreen">
    &quot;True, if energy is flowing INTO and not out of flange flange_a&quot;</font>;


<font color="blue">equation </font>
  phi = phi_a;
  phi = phi_b;
  power_a = flange_a.tau*<font color="red">der</font>(phi);
  driving_a = power_a &gt;= 0;
  flange_b.tau = -(<font color="blue">if </font>driving_a<font color="blue"> then </font>eta*flange_a.tau<font color="blue"> else </font>flange_a.tau/eta);
<font color="blue">end </font>GearEfficiency;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Gear<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.GearI.png" ALT="Modelica.Mechanics.Rotational.Gear" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Gear"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Gear</H2>
<B>Realistic model of a gearbox</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.GearD.png" ALT="Modelica.Mechanics.Rotational.Gear">
<H3>Information</H3>
<PRE></pre>
<p>
This component models the essential effects of a gearbox, in particular
gear <b>efficiency</b> due to friction between the teeth, <b>bearing friction</b>,
gear <b>elasticity</b> and <b>damping</b>, <b>backlash</b>.
The inertia of the gear wheels is not modeled. If necessary, inertia
has to be taken into account by connecting components of model Inertia
to the left and/or the right flange.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>ratio</TD><TD>1</TD><TD>transmission ratio (flange_a.phi/flange_b.phi)</TD></TR>
<TR><TD>Real</TD><TD>eta</TD><TD>1</TD><TD>Gear efficiency</TD></TR>
<TR><TD>Real</TD><TD>friction_pos[:, :]</TD><TD>[0, 1]</TD><TD>[w,tau] positive sliding friction characteristic (w&gt;=0)</TD></TR>
<TR><TD>Real</TD><TD>peak</TD><TD>1</TD><TD>peak*friction_pos[1,2] = maximum friction torque at zero velocity</TD></TR>
<TR><TD>Real</TD><TD>c</TD><TD>1.e5</TD><TD>Gear elasticity (spring constant) [N.m/rad]</TD></TR>
<TR><TD>Real</TD><TD>d</TD><TD>0</TD><TD>(relative) gear damping [N.m.s/rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>b</TD><TD>0</TD><TD>Total backlash [rad]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Gear <font color="darkgreen">&quot;Realistic model of a gearbox&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0b6b4a01dc94df45angesAndBearingH"
>Interfaces.TwoFlangesAndBearingH</A>;

  <font color="blue">parameter </font>Real ratio=1 <font color="darkgreen">&quot;transmission ratio (flange_a.phi/flange_b.phi)&quot;</font>;
  <font color="blue">parameter </font>Real eta(
    min=Modelica.Constants.small,
    max=1) = 1 <font color="darkgreen">&quot;Gear efficiency&quot;</font>;
  <font color="blue">parameter </font>Real friction_pos[:, :]=[0, 1] <font color="darkgreen">
    &quot;[w,tau] positive sliding friction characteristic (w&gt;=0)&quot;</font>;
  <font color="blue">parameter </font>Real peak(<font color="blue">final </font>min=1) = 1 <font color="darkgreen">
    &quot;peak*friction_pos[1,2] = maximum friction torque at zero velocity&quot;</font>;
  <font color="blue">parameter </font>Real c(
    <font color="blue">final </font>unit=&quot;N.m/rad&quot;,
    <font color="blue">final </font>min=Modelica.Constants.small) = 1.e5 <font color="darkgreen">
    &quot;Gear elasticity (spring constant)&quot;</font>;
  <font color="blue">parameter </font>Real d(
    <font color="blue">final </font>unit=&quot;N.m.s/rad&quot;,
    <font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;(relative) gear damping&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> b(<font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;Total backlash&quot;</font>;

  <A HREF="Modelica_Mechanics_Rotational.html#ecb5380e310a507ctional.IdealGear"
>IdealGear</A> gearRatio(<font color="blue">final </font>ratio=ratio);
  <A HREF="Modelica_Mechanics_Rotational.html#e3b7edc27e8821bfl.GearEfficiency"
>GearEfficiency</A> gearEfficiency(<font color="blue">final </font>eta=eta);
  <A HREF="Modelica_Mechanics_Rotational.html#60da7067eeaeb788l.ElastoBacklash"
>ElastoBacklash</A> elastoBacklash(
    <font color="blue">final </font>b=b,
    <font color="blue">final </font>c=c,
    <font color="blue">final </font>phi_rel0=0,
    <font color="blue">final </font>d=d);
  <A HREF="Modelica_Mechanics_Rotational.html#3853572291d81c7f.BearingFriction"
>BearingFriction</A> bearingFriction(<font color="blue">final </font>tau_pos=friction_pos, <font color="blue">final </font>peak=peak);
<font color="blue">equation </font>
  <font color="red">connect</font>(flange_a, gearRatio.flange_a);
  <font color="red">connect</font>(gearRatio.flange_b, gearEfficiency.flange_a);
  <font color="red">connect</font>(gearEfficiency.flange_b, bearingFriction.flange_a);
  <font color="red">connect</font>(bearingFriction.flange_b, elastoBacklash.flange_a);
  <font color="red">connect</font>(elastoBacklash.flange_b, flange_b);
  <font color="red">connect</font>(gearRatio.bearing, adapter.flange_b);
  <font color="red">connect</font>(gearEfficiency.bearing, adapter.flange_b);
  <font color="red">connect</font>(bearingFriction.bearing, adapter.flange_b);
<font color="blue">end </font>Gear;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Gear2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.GearI.png" ALT="Modelica.Mechanics.Rotational.Gear2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Gear2"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Gear2</H2>
<B>Realistic model of a gearbox (based on LossyGear)</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.Gear2D.png" ALT="Modelica.Mechanics.Rotational.Gear2">
<H3>Information</H3>
<PRE></pre>
<p>This component models the essential effects of a gearbox, in
particular</p>
<ul>
  <li>in component <b>lossyGear</b></li>
    <ul>
      <li>gear <b>efficiency</b> due to friction between the teeth</li>
      <li><b>bearing friction</b></li>
    </ul>
  <li>in component <b>elastoBacklash</b></li>
    <ul>
      <li>gear <b>elasticity</b></li>
      <li><b>damping</b></li>
      <li><b>backlash</b></li>
    </ul>
</ul>
<p>The inertia of the gear wheels is not modeled. If necessary,
inertia has to be taken into account by connecting components of
model Inertia to the left and/or the right flange of component
GearNew.</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>i</TD><TD>1</TD><TD>transmission ratio (flange_a.phi/flange_b.phi)</TD></TR>
<TR><TD>Real</TD><TD>lossTable[:, 5]</TD><TD>[0, 1, 1, 0, 0]</TD><TD>Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)</TD></TR>
<TR><TD>Real</TD><TD>c</TD><TD>1.e5</TD><TD>Gear elasticity (spring constant) [N.m/rad]</TD></TR>
<TR><TD>Real</TD><TD>d</TD><TD>0</TD><TD>(relative) gear damping [N.m.s/rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>b</TD><TD>0</TD><TD>Total backlash [rad]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Gear2 <font color="darkgreen">&quot;Realistic model of a gearbox (based on LossyGear)&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0b6b4a01dc94df45angesAndBearingH"
>Interfaces.TwoFlangesAndBearingH</A>;

  <font color="blue">parameter </font>Real i=1 <font color="darkgreen">&quot;transmission ratio (flange_a.phi/flange_b.phi)&quot;</font>;
  <font color="blue">parameter </font>Real lossTable[:, 5]=[0, 1, 1, 0, 0] <font color="darkgreen">
    &quot;Array for mesh efficiencies and bearing friction depending on speed (see docu of LossyGear)&quot;</font>;

  <font color="blue">parameter </font>Real c(
    <font color="blue">final </font>unit=&quot;N.m/rad&quot;,
    <font color="blue">final </font>min=Modelica.Constants.small) = 1.e5 <font color="darkgreen">
    &quot;Gear elasticity (spring constant)&quot;</font>;
  <font color="blue">parameter </font>Real d(
    <font color="blue">final </font>unit=&quot;N.m.s/rad&quot;,
    <font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;(relative) gear damping&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> b(<font color="blue">final </font>min=0) = 0 <font color="darkgreen">&quot;Total backlash&quot;</font>;

  <A HREF="Modelica_Mechanics_Rotational.html#ce8c5f7b945a5521tional.LossyGear"
>LossyGear</A> lossyGear(<font color="blue">final </font>i=i, <font color="blue">final </font>lossTable=lossTable);
  <A HREF="Modelica_Mechanics_Rotational.html#60da7067eeaeb788l.ElastoBacklash"
>ElastoBacklash</A> elastoBacklash(
    <font color="blue">final </font>b=b,
    <font color="blue">final </font>c=c,
    <font color="blue">final </font>phi_rel0=0,
    <font color="blue">final </font>d=d);
<font color="blue">equation </font>
  <font color="red">connect</font>(flange_a, lossyGear.flange_a);
  <font color="red">connect</font>(lossyGear.flange_b, elastoBacklash.flange_a);
  <font color="red">connect</font>(elastoBacklash.flange_b, flange_b);
  <font color="red">connect</font>(lossyGear.bearing, adapter.flange_b);
<font color="blue">end </font>Gear2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Position<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.PositionI.png" ALT="Modelica.Mechanics.Rotational.Position" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="6f7bfddbdd04eb05ational.Position"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Position</H2>
<B>Forced movement of a flange according to a reference angle signal</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.PositionD.png" ALT="Modelica.Mechanics.Rotational.Position">
<H3>Information</H3>
<PRE></pre>
<p>
The input signal <b>phi_ref</b> defines the <b>reference
angle</b> in [rad]. Flange <b>flange_b</b> is <b>forced</b>
to move according to this reference motion. According to parameter
<b>exact</b> (default = <b>false</b>), this is done in the following way:
<ol>
<li><b>exact=true</b><br>
    The reference angle is treated <b>exactly</b>. This is only possible, if
    the input signal is defined by an analytical function which can be
    differentiated at least twice. If this prerequisite is fulfilled,
    the Modelica translator will differentiate the input signal twice
    in order to compute the reference acceleration of the flange.</li>
<li><b>exact=false</b><br>
    The reference angle is <b>filtered</b> and the second derivative
    of the filtered curve is used to compute the reference acceleration
    of the flange. This second derivative is <b>not</b> computed by
    numerical differentiation but by an appropriate realization of the
    filter. For filtering, a second order Bessel filter is used.
    The critical frequency (also called cut-off frequency) of the
    filter is defined via parameter <b>f_crit</b> in [Hz]. This value
    should be selected in such a way that it is higher as the essential
    low frequencies in the signal.</li>
</ol>
<p>
The input signal can be provided from one of the signal generator
blocks of the block library Modelica.Blocks.Sources.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>exact</TD><TD>false</TD><TD>true/false exact treatment/filtering the input signal</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_crit</TD><TD>50</TD><TD>if exact=false, critical frequency of filter to filter input signal [Hz]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>phi_ref</TD><TD>reference angle of flange_b as input signal</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Position <font color="darkgreen">
  &quot;Forced movement of a flange according to a reference angle signal&quot;</font>

  <font color="blue">parameter </font>Boolean exact=false <font color="darkgreen">
    &quot;true/false exact treatment/filtering the input signal&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>SI.Frequency</A> f_crit=50 <font color="darkgreen">
    &quot;if exact=false, critical frequency of filter to filter input signal&quot;</font>;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> phi_ref( <font color="blue">redeclare </font><font color="blue">type</font> SignalType =
        <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A>) <font color="darkgreen">&quot;reference angle of flange_b as input signal&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi <font color="darkgreen">&quot;absolute rotation angle of flange flange_b&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w <font color="darkgreen">&quot;absolute angular velocity of flange flange_b&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a <font color="darkgreen">
    &quot;absolute angular acceleration of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau_support <font color="darkgreen">&quot;Support torque&quot;</font>;
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real w_crit=2*Modelica.Constants.pi*f_crit <font color="darkgreen">
    &quot;critical frequency in [1/s]&quot;</font>;
  <font color="blue">constant </font>Real af=1.3617 <font color="darkgreen">&quot;s coefficient of Bessel filter&quot;</font>;
  <font color="blue">constant </font>Real bf=0.6180 <font color="darkgreen">&quot;s*s coefficient of Bessel filter&quot;</font>;
<font color="blue">public </font>
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> flange_b;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> bearing;
<font color="blue">equation </font>
  0 = flange_b.tau + tau_support;

  <font color="blue">if </font><font color="red">cardinality</font>(bearing) == 0<font color="blue"> then</font>
    bearing.phi = 0;
  <font color="blue">else</font>
    bearing.tau = tau_support;
  <font color="blue">end if</font>;

  phi = flange_b.phi;
  w =<font color="red"> der</font>(phi);
  a =<font color="red"> der</font>(w);

  <font color="blue">if </font>exact<font color="blue"> then</font>
    phi = phi_ref;
  <font color="blue">else</font>
    <font color="darkgreen">// Filter: a = phi_ref*s^2/(1 + (af/w_crit)*s + (bf/w_crit^2)*s^2)</font>
    a = ((phi_ref - phi)*w_crit - af*w)*(w_crit/bf);
  <font color="blue">end if</font>;

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="blue">if </font><font color="blue">not </font>exact<font color="blue"> then</font>
    phi = phi_ref;
  <font color="blue">end if</font>;
<font color="blue">end </font>Position;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Speed<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.SpeedI.png" ALT="Modelica.Mechanics.Rotational.Speed" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Speed"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Speed</H2>
<B>Forced movement of a flange according to a reference angular velocity signal</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.PositionD.png" ALT="Modelica.Mechanics.Rotational.Speed">
<H3>Information</H3>
<PRE></pre>
<p>
The input signal <b>w_ref</b> defines the <b>reference
angle</b> in [rad]. Flange <b>flange_b</b> is <b>forced</b>
to move according to this reference motion. According to parameter
<b>exact</b> (default = <b>false</b>), this is done in the following way:
<ol>
<li><b>exact=true</b><br>
    The reference angle is treated <b>exactly</b>. This is only possible, if
    the input signal is defined by an analytical function which can be
    differentiated at least twice. If this prerequisite is fulfilled,
    the Modelica translator will differentiate the input signal twice
    in order to compute the reference acceleration of the flange.</li>
<li><b>exact=false</b><br>
    The reference angle is <b>filtered</b> and the second derivative
    of the filtered curve is used to compute the reference acceleration
    of the flange. This second derivative is <b>not</b> computed by
    numerical differentiation but by an appropriate realization of the
    filter. For filtering, a second order Bessel filter is used.
    The critical frequency (also called cut-off frequency) of the
    filter is defined via parameter <b>f_crit</b> in [Hz]. This value
    should be selected in such a way that it is higher as the essential
    low frequencies in the signal.</li>
</ol>
<p>
The input signal can be provided from one of the signal generator
blocks of the block library Modelica.Blocks.Sources.
</p>
<p><b>Release Notes:</b></p>
<ul>
<li><i>October 27, 2003</i>
       by <a href="http://www.robotic.dlr.de/Christian.Schweiger/">Christian Schweiger</a>.<br>
       Realized based on component <tt>Position</tt> (implemented by
       <a href="http://www.robotic.dlr.de/Martin.Otter/">Martin Otter</a>).</li>
</ul>
<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>exact</TD><TD>false</TD><TD>true/false exact treatment/filtering the input signal</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_crit</TD><TD>50</TD><TD>if exact=false, critical frequency of filter to filter input signal [Hz]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>w_ref</TD><TD>Reference angular velocity of flange_b as input signal</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Speed <font color="darkgreen">
  &quot;Forced movement of a flange according to a reference angular velocity signal&quot;</font>

  <font color="blue">parameter </font>Boolean exact=false <font color="darkgreen">
    &quot;true/false exact treatment/filtering the input signal&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>SI.Frequency</A> f_crit=50 <font color="darkgreen">
    &quot;if exact=false, critical frequency of filter to filter input signal&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_ref <font color="darkgreen">
    &quot;reference angle defined by time integration of input signal&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi <font color="darkgreen">&quot;absolute rotation angle of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w <font color="darkgreen">&quot;absolute angular velocity of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a <font color="darkgreen">&quot;absolute angular acceleration of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau_support <font color="darkgreen">&quot;Support torque&quot;</font>;
<font color="blue">protected </font>
  <font color="blue">parameter </font>Real w_crit=2*Constants.pi*f_crit <font color="darkgreen">&quot;critical frequency in [1/s]&quot;</font>;
<font color="blue">public </font>
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> flange_b;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Blocks.Interfaces.RealInput</A> w_ref(<font color="blue">redeclare </font><font color="blue">type</font> SignalType =
        <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A>) <font color="darkgreen">
    &quot;Reference angular velocity of flange_b as input signal&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> bearing;
<font color="blue">equation </font>
  0 = flange_b.tau + tau_support;

  <font color="blue">if </font><font color="red">cardinality</font>(bearing) == 0<font color="blue"> then</font>
    bearing.phi = 0;
  <font color="blue">else</font>
    bearing.tau = tau_support;
  <font color="blue">end if</font>;

  <font color="red">der</font>(phi_ref) = w_ref;
  phi = flange_b.phi;
  w =<font color="red"> der</font>(phi);
  a =<font color="red"> der</font>(w);

  <font color="blue">if </font>exact<font color="blue"> then</font>
    w = w_ref;
  <font color="blue">else</font>
    <font color="darkgreen">// Filter: a = w_ref/(1 + (1/w_crit)*s)</font>
    a = (w_ref - w)*w_crit;
  <font color="blue">end if</font>;
<font color="blue">initial </font><font color="blue">equation </font>
  <font color="blue">if </font><font color="blue">not </font>exact<font color="blue"> then</font>
    w = w_ref;
  <font color="blue">end if</font>;
<font color="blue">end </font>Speed;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Accelerate<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.AccelerateI.png" ALT="Modelica.Mechanics.Rotational.Accelerate" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="5d4d9d8723608712ional.Accelerate"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Accelerate</H2>
<B>Forced movement of a flange according to an acceleration signal</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.PositionD.png" ALT="Modelica.Mechanics.Rotational.Accelerate">
<H3>Information</H3>
<PRE></pre>
<p>
The input signal <b>a</b> defines an <b>angular acceleration</b>
in [rad/s2]. Flange <b>flange_b</b> is <b>forced</b> to move with
this acceleration. The angular velocity <b>w</b> and the rotation angle
<b>phi</b> of the flange are automatically determined by integration of
the acceleration.
</p>
<p>
The input signal can be provided from one of the signal generator
blocks of the block library Modelica.Blocks.Sources.
</p>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_start</TD><TD>0</TD><TD>Start angle [rad]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_start</TD><TD>0</TD><TD>Start angular velocity [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>a</TD><TD>absolute angular acceleration of flange_b as input signal</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Accelerate <font color="darkgreen">
  &quot;Forced movement of a flange according to an acceleration signal&quot;</font>

  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_start=0 <font color="darkgreen">&quot;Start angle&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_start=0 <font color="darkgreen">&quot;Start angular velocity&quot;</font>;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi(<font color="blue">final </font>start=phi_start, <font color="blue">final </font>fixed=true) <font color="darkgreen">
    &quot;absolute rotation angle of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w(<font color="blue">final </font>start=w_start, <font color="blue">final </font>fixed=true) <font color="darkgreen">
    &quot;absolute angular velocity of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau_support <font color="darkgreen">&quot;Support torque&quot;</font>;

  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> flange_b;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Blocks.Interfaces.RealInput</A> a(
        <font color="blue">redeclare </font><font color="blue">type</font> SignalType = <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A>) <font color="darkgreen">
    &quot;absolute angular acceleration of flange_b as input signal&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> bearing;
<font color="blue">equation </font>
  0 = flange_b.tau + tau_support;

  <font color="blue">if </font><font color="red">cardinality</font>(bearing) == 0<font color="blue"> then</font>
    bearing.phi = 0;
  <font color="blue">else</font>
    bearing.tau = tau_support;
  <font color="blue">end if</font>;

  phi = flange_b.phi;
  w =<font color="red"> der</font>(phi);
  a =<font color="red"> der</font>(w);
<font color="blue">end </font>Accelerate;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Move<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.MoveI.png" ALT="Modelica.Mechanics.Rotational.Move" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Move"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Move</H2>
<B>Forced movement of a flange according to an angle, speed and angular acceleration signal</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.MoveD.png" ALT="Modelica.Mechanics.Rotational.Move">
<H3>Information</H3>
<PRE></pre>
<p>
Flange <b>flange_b</b> is <b>forced</b> to move with a predefined motion
according to the input signals:
</p>
<pre>
    u[1]: angle of flange
    u[2]: angular velocity of flange
    u[3]: angular acceleration of flange
</pre>
<p>
The user has to guarantee that the input signals are consistent to each other,
i.e., that u[2] is the derivative of u[1] and that
u[3] is the derivative of u[2]. There are, however,
also applications where by purpose these conditions do not hold. For example,
if only the position dependent terms of a mechanical system shall be
calculated, one may provide angle = angle(t) and set the angular velocity
and the angular acceleration to zero.
</p>
<p>
The input signals can be provided from one of the signal generator
blocks of the block library Modelica.Blocks.Sources.
</p>

<pre>
</PRE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>u[3]</TD><TD>angle, angular velocity and angular acceleration of flange_b as input signals</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>Flange that is forced to move according to input signals u</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>Bearing flange (if not connected, it is assumed that it is fixed on ground)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Move <font color="darkgreen">
  &quot;Forced movement of a flange according to an angle, speed and angular acceleration signal&quot;</font>

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi <font color="darkgreen">&quot;absolute rotation angle of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w <font color="darkgreen">&quot;absolute angular velocity of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a <font color="darkgreen">&quot;absolute angular acceleration of flange flange_b&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A> tau_support <font color="darkgreen">&quot;Support torque&quot;</font>;

  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> u[3] <font color="darkgreen">
    &quot;angle, angular velocity and angular acceleration of flange_b as input signals&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> flange_b <font color="darkgreen">
    &quot;Flange that is forced to move according to input signals u&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> bearing <font color="darkgreen">
    &quot;Bearing flange (if not connected, it is assumed that it is fixed on ground)&quot;</font>;

<font color="blue">protected </font>
  <font color="blue">function</font> position
  annotation(derivative=<A HREF="Modelica_Mechanics_Rotational.html#1b7a9c4ea9302495ove.position_der"
>position_der</A>);
     <font color="blue">input </font>Real q_qd_qdd[3] <font color="darkgreen">&quot;Required values for position, speed, acceleration&quot;</font>;
     <font color="blue">input </font>Real dummy <font color="darkgreen">
      &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;</font>;
     <font color="blue">output </font>Real q;
  <font color="blue">algorithm </font>
    q :=q_qd_qdd[1];
  <font color="blue">end </font>position;

  <font color="blue">function</font> position_der
  annotation(derivative=<A HREF="Modelica_Mechanics_Rotational.html#0fbdfc1c261b9287ve.position_der2"
>position_der2</A>);
     <font color="blue">input </font>Real q_qd_qdd[3] <font color="darkgreen">&quot;Required values for position, speed, acceleration&quot;</font>;
     <font color="blue">input </font>Real dummy <font color="darkgreen">
      &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;</font>;
     <font color="blue">input </font>Real dummy_der;
     <font color="blue">output </font>Real qd;
  <font color="blue">algorithm </font>
    qd :=q_qd_qdd[2];
  <font color="blue">end </font>position_der;

  <font color="blue">function</font> position_der2
     <font color="blue">input </font>Real q_qd_qdd[3] <font color="darkgreen">&quot;Required values for position, speed, acceleration&quot;</font>;
     <font color="blue">input </font>Real dummy <font color="darkgreen">
      &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;</font>;
     <font color="blue">input </font>Real dummy_der;
     <font color="blue">input </font>Real dummy_der2;
     <font color="blue">output </font>Real qdd;
  <font color="blue">algorithm </font>
    qdd :=q_qd_qdd[3];
  <font color="blue">end </font>position_der2;
<font color="blue">equation </font>
  0 = flange_b.tau + tau_support;

  <font color="blue">if </font><font color="red">cardinality</font>(bearing) == 0<font color="blue"> then</font>
    bearing.phi = 0;
  <font color="blue">else</font>
    bearing.tau = tau_support;
  <font color="blue">end if</font>;

  phi = flange_b.phi;
  phi =<font color="red"> position</font>(u,time);
  w =<font color="red"> der</font>(phi);
  a =<font color="red"> der</font>(w);
<font color="blue">end </font>Move;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Fixed<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.FixedI.png" ALT="Modelica.Mechanics.Rotational.Fixed" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Fixed"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Fixed</H2>
<B>Flange fixed in housing at a given angle</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.FixedD.png" ALT="Modelica.Mechanics.Rotational.Fixed">
<H3>Information</H3>
<PRE></pre>
<p>
The <b>flange</b> of a 1D rotational mechanical system is <b>fixed</b>
at an angle phi0 in the <b>housing</b>. May be used:
</p>
<ul>
<li> to connect a compliant element, such as a spring or a damper,
     between an inertia or gearbox component and the housing.
<li> to fix a rigid element, such as an inertia, with a specific
     angle to the housing.
</ul>

<pre>
</PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi0</TD><TD>0</TD><TD>Fixed offset angle of housing [rad]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(right) flange fixed in housing</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Fixed <font color="darkgreen">&quot;Flange fixed in housing at a given angle&quot;</font>
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi0=0 <font color="darkgreen">&quot;Fixed offset angle of housing&quot;</font>;

  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> flange_b <font color="darkgreen">&quot;(right) flange fixed in housing&quot;</font>;
<font color="blue">equation </font>
  flange_b.phi = phi0;
<font color="blue">end </font>Fixed;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Torque<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.TorqueI.png" ALT="Modelica.Mechanics.Rotational.Torque" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Torque"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Torque</H2>
<B>Input signal acting as external torque on a flange</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.TorqueD.png" ALT="Modelica.Mechanics.Rotational.Torque">
<H3>Information</H3>
<PRE></pre>
<p>
The input signal <b>tau</b> defines an external
torque in [Nm] which acts (with negative sign) at
a flange connector, i.e., the component connected to this
flange is driven by torque <b>tau</b>.</p>
<p>
The input signal can be provided from one of the signal generator
blocks of Modelica.Blocks.Sources.
</p>

<pre>
</PRE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>tau</TD><TD>Torque driving the flange (a positive value accelerates the flange)</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>(Right) flange</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Torque <font color="darkgreen">&quot;Input signal acting as external torque on a flange&quot;</font>
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> tau( <font color="blue">redeclare </font><font color="blue">type</font> SignalType =
        <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A>) <font color="darkgreen">
    &quot;Torque driving the flange (a positive value accelerates the flange)&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> flange_b <font color="darkgreen">&quot;(Right) flange&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Interfaces.Flange_a</A> bearing;
<font color="blue">equation </font>
  flange_b.tau = -tau;

  <font color="blue">if </font><font color="red">cardinality</font>(bearing) == 0<font color="blue"> then</font>
    bearing.phi = 0;
  <font color="blue">else</font>
    bearing.tau = tau;
  <font color="blue">end if</font>;
<font color="blue">end </font>Torque;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Torque2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.Torque2I.png" ALT="Modelica.Mechanics.Rotational.Torque2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Mechanics.Rotational.Torque2"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.Torque2</H2>
<B>Input signal acting as torque on two flanges</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.Torque2D.png" ALT="Modelica.Mechanics.Rotational.Torque2">
<H3>Information</H3>
<PRE></pre>
<p>
The input signal <b>tau</b> defines an external
torque in [Nm] which acts at both flange connectors,
i.e., the components connected to these flanges are driven by torque <b>tau</b>.</p>
<p>The input signal can be provided from one of the signal generator
blocks of Modelica.Blocks.Sources.</p>

<pre>
</PRE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>tau</TD><TD>Torque driving the two flanges (a positive value accelerates the flange)</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> Torque2 <font color="darkgreen">&quot;Input signal acting as torque on two flanges&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#1b11502c909bc8b7faces.TwoFlanges"
>Interfaces.TwoFlanges</A>;

  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> tau( <font color="blue">redeclare </font><font color="blue">type</font> SignalType =
        <A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>SI.Torque</A>) <font color="darkgreen">
    &quot;Torque driving the two flanges (a positive value accelerates the flange)&quot;</font>;

<font color="blue">equation </font>
  flange_a.tau = tau;
  flange_b.tau = -tau;
<font color="blue">end </font>Torque2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LinearSpeedDependentTorque<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.LinearSpeedDependentTorqueI.png" ALT="Modelica.Mechanics.Rotational.LinearSpeedDependentTorque" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="781da0e966a52564dDependentTorque"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.LinearSpeedDependentTorque</H2>
<B>Linear dependency of torque versus speed</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.LinearSpeedDependentTorqueD.png" ALT="Modelica.Mechanics.Rotational.LinearSpeedDependentTorque">
<H3>Information</H3>
<PRE></pre>
<p>
Model of torque, linearly dependent on angular velocity of flange.<br>
Parameter TorqueDirection chooses whether direction of torque is the same in both directions of rotation or not.
</p>
<pre></PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Torque</A></TD><TD>tau_nominal</TD><TD>&nbsp;</TD><TD>nominal torque (if negative, torque is acting as load) [N.m]</TD></TR>
<TR><TD>Boolean</TD><TD>TorqueDirection</TD><TD>true</TD><TD>same direction of torque in both directions of rotation</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_nominal</TD><TD>&nbsp;</TD><TD>nominal speed [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange</TD><TD>Flange on which torque is acting</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>Bearing at which the reaction torque (i.e., -flange.tau) is acting</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> LinearSpeedDependentTorque <font color="darkgreen">
  &quot;Linear dependency of torque versus speed&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#b6c7663106494e34dDependentTorque"
>Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque</A>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Modelica.SIunits.Torque</A> tau_nominal <font color="darkgreen">
    &quot;nominal torque (if negative, torque is acting as load)&quot;</font>;
  <font color="blue">parameter </font>Boolean TorqueDirection=true <font color="darkgreen">
    &quot;same direction of torque in both directions of rotation&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_nominal(min=Modelica.Constants.eps) <font color="darkgreen">
    &quot;nominal speed&quot;</font>;
<font color="blue">equation </font>
  <font color="blue">if </font>TorqueDirection<font color="blue"> then</font>
    tau = -tau_nominal*<font color="red">abs</font>(w/w_nominal);
  <font color="blue">else</font>
    tau = -tau_nominal*(w/w_nominal);
  <font color="blue">end if</font>;
<font color="blue">end </font>LinearSpeedDependentTorque;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE QuadraticSpeedDependentTorque<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorqueI.png" ALT="Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorque" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="5e6f29c07eaacd0edDependentTorque"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.QuadraticSpeedDependentTorque</H2>
<B>Quadratic dependency of torque versus speed</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.LinearSpeedDependentTorqueD.png" ALT="Modelica.Mechanics.Rotational.QuadraticSpeedDependentTorque">
<H3>Information</H3>
<PRE></pre>
<p>
Model of torque, quadratic dependent on angular velocity of flange.<br>
Parameter TorqueDirection chooses whether direction of torque is the same in both directions of rotation or not.
</p>
<pre></PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Torque</A></TD><TD>tau_nominal</TD><TD>&nbsp;</TD><TD>nominal torque (if negative, torque is acting as load) [N.m]</TD></TR>
<TR><TD>Boolean</TD><TD>TorqueDirection</TD><TD>true</TD><TD>same direction of torque in both directions of rotation</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_nominal</TD><TD>&nbsp;</TD><TD>nominal speed [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange</TD><TD>Flange on which torque is acting</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>Bearing at which the reaction torque (i.e., -flange.tau) is acting</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> QuadraticSpeedDependentTorque <font color="darkgreen">
  &quot;Quadratic dependency of torque versus speed&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#b6c7663106494e34dDependentTorque"
>Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque</A>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Modelica.SIunits.Torque</A> tau_nominal <font color="darkgreen">
    &quot;nominal torque (if negative, torque is acting as load)&quot;</font>;
  <font color="blue">parameter </font>Boolean TorqueDirection=true <font color="darkgreen">
    &quot;same direction of torque in both directions of rotation&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_nominal(min=Modelica.Constants.eps) <font color="darkgreen">
    &quot;nominal speed&quot;</font>;
<font color="blue">equation </font>
  <font color="blue">if </font>TorqueDirection<font color="blue"> then</font>
    tau = -tau_nominal*(w/w_nominal)^2;
  <font color="blue">else</font>
    tau = -tau_nominal*<font color="red">smooth</font>(1,<font color="blue">if </font>w &gt;= 0<font color="blue"> then </font>(w/w_nominal)^2<font color="blue"> else </font>-(w/w_nominal)^2);
  <font color="blue">end if</font>;
<font color="blue">end </font>QuadraticSpeedDependentTorque;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE ConstantTorque<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.ConstantTorqueI.png" ALT="Modelica.Mechanics.Rotational.ConstantTorque" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="24b3d1c0f761f82cl.ConstantTorque"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.ConstantTorque</H2>
<B>Constant torque, not dependent on speed</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.LinearSpeedDependentTorqueD.png" ALT="Modelica.Mechanics.Rotational.ConstantTorque">
<H3>Information</H3>
<PRE></pre>
<p>
Model of constant torque, not dependent on angular velocity of flange.<br>
Positive torque acts accelerating.
</p>
<pre></PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Torque</A></TD><TD>tau_constant</TD><TD>&nbsp;</TD><TD>constant torque (if negative, torque is acting as load) [N.m]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange</TD><TD>Flange on which torque is acting</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>Bearing at which the reaction torque (i.e., -flange.tau) is acting</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> ConstantTorque <font color="darkgreen">&quot;Constant torque, not dependent on speed&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#b6c7663106494e34dDependentTorque"
>Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque</A>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Modelica.SIunits.Torque</A> tau_constant <font color="darkgreen">
    &quot;constant torque (if negative, torque is acting as load)&quot;</font>;
<font color="blue">equation </font>
  tau = -tau_constant;
<font color="blue">end </font>ConstantTorque;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE ConstantSpeed<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.ConstantSpeedI.png" ALT="Modelica.Mechanics.Rotational.ConstantSpeed" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="37270de94c44d153al.ConstantSpeed"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.ConstantSpeed</H2>
<B>Constant speed, not dependent on torque</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.LinearSpeedDependentTorqueD.png" ALT="Modelica.Mechanics.Rotational.ConstantSpeed">
<H3>Information</H3>
<PRE></pre>
<p>
Model of <b>fixed</b> angular verlocity of flange, not dependent on torque.
</p>
<pre></PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_fixed</TD><TD>&nbsp;</TD><TD>fixed speed (if negative, torque is acting as load) [rad/s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange</TD><TD>Flange on which torque is acting</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>Bearing at which the reaction torque (i.e., -flange.tau) is acting</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> ConstantSpeed <font color="darkgreen">&quot;Constant speed, not dependent on torque&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#b6c7663106494e34dDependentTorque"
>Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque</A>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_fixed <font color="darkgreen">
    &quot;fixed speed (if negative, torque is acting as load)&quot;</font>;
<font color="blue">equation </font>
  w = w_fixed;
<font color="blue">end </font>ConstantSpeed;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE TorqueStep<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.TorqueStepI.png" ALT="Modelica.Mechanics.Rotational.TorqueStep" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="8de49d8c1172fdaaional.TorqueStep"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.TorqueStep</H2>
<B>Constant torque, not dependent on speed</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.LinearSpeedDependentTorqueD.png" ALT="Modelica.Mechanics.Rotational.TorqueStep">
<H3>Information</H3>
<PRE></pre>
<p>
Model of a torque step at time .<br>
Positive torque acts accelerating.
</p>
<pre></PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Torque</A></TD><TD>stepTorque</TD><TD>1</TD><TD>height of torque step (if negative, torque is acting as load) [N.m]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Torque</A></TD><TD>offsetTorque</TD><TD>0</TD><TD>offset of torque [N.m]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>Time</A></TD><TD>startTime</TD><TD>0</TD><TD>output = offset for time &lt; startTime [s]</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange</TD><TD>Flange on which torque is acting</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>bearing</TD><TD>Bearing at which the reaction torque (i.e., -flange.tau) is acting</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> TorqueStep <font color="darkgreen">&quot;Constant torque, not dependent on speed&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#b6c7663106494e34dDependentTorque"
>Modelica.Mechanics.Rotational.Interfaces.PartialSpeedDependentTorque</A>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Modelica.SIunits.Torque</A> stepTorque=1 <font color="darkgreen">
    &quot;height of torque step (if negative, torque is acting as load)&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Torque"
>Modelica.SIunits.Torque</A> offsetTorque=0 <font color="darkgreen">&quot;offset of torque&quot;</font>;
  <font color="blue">parameter </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Time"
>Modelica.SIunits.Time</A> startTime=0 <font color="darkgreen">
    &quot;output = offset for time &lt; startTime&quot;</font>;

<font color="blue">equation </font>
  tau = -offsetTorque - (<font color="blue">if </font>time &lt; startTime<font color="blue"> then </font>0<font color="blue"> else </font>stepTorque);
<font color="blue">end </font>TorqueStep;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE RelativeStates<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.RelativeStatesI.png" ALT="Modelica.Mechanics.Rotational.RelativeStates" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="9b98d1d4199066dcl.RelativeStates"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.RelativeStates</H2>
<B>Definition of relative state variables</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.RelativeStatesD.png" ALT="Modelica.Mechanics.Rotational.RelativeStates">
<H3>Information</H3>
<PRE></pre>
<p>
Usually, the absolute angle and the absolute angular velocity of
Modelica.Mechanics.Rotational.Inertia models are used as state variables.
In some circumstances, relative quantities are better suited, e.g.,
because it may be easier to supply initial values.
In such cases, model <b>RelativeStates</b> allows the definition of state variables
in the following way:
</p>
<ul>
<li> Connect an instance of this model between two flange connectors.</li>
<li> The <b>relative rotation angle</b> and the <b>relative angular velocity</b>
     between the two connectors are used as <b>state variables</b>.
</ul>
<p>
An example is given in the next figure
</p>
<IMG SRC="../Images/relativeStates.png" ALT="relativeStates">
<p>
Here, the relative angle and the relative angular velocity between
the two inertias are used as state variables. Additionally, the
simulator selects either the absolute angle and absolute angular
velocity of model inertia1 or of model inertia2 as state variables.
</p>

<pre>
</PRE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23615c7e1b041erfaces.Flange_a"
>Flange_a</A></TD><TD>flange_a</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange_b</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> RelativeStates <font color="darkgreen">&quot;Definition of relative state variables&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#1b11502c909bc8b7faces.TwoFlanges"
>Interfaces.TwoFlanges</A>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_rel(stateSelect=StateSelect.prefer) <font color="darkgreen">
    &quot;relative rotation angle used as state variable&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w_rel(stateSelect=StateSelect.prefer) <font color="darkgreen">
    &quot;relative angular velocity used as state variable&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a_rel <font color="darkgreen">&quot;relative angular acceleration&quot;</font>;
<font color="blue">equation </font>
  phi_rel = flange_b.phi - flange_a.phi;
  w_rel =<font color="red"> der</font>(phi_rel);
  a_rel =<font color="red"> der</font>(w_rel);
  flange_a.tau = 0;
  flange_b.tau = 0;
<font color="blue">end </font>RelativeStates;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE InitializeFlange<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.InitializeFlangeI.png" ALT="Modelica.Mechanics.Rotational.InitializeFlange" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="770f8c3f10ba9fe4InitializeFlange"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational"
>Modelica.Mechanics.Rotational</A>.InitializeFlange</H2>
<B>Initializes a flange with pre-defined angle, speed and angular acceleration (usually, this is reference data from a control bus)</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.InitializeFlangeD.png" ALT="Modelica.Mechanics.Rotational.InitializeFlange">
<H3>Information</H3>
<PRE></pre>
<p>
This component is used to optionally initialize the angle, speed,
and/or angular acceleration of the flange to which this component
is connected. Via parameters use_phi_start, use_w_start, use_a_start
the corresponding input signals phi_start, w_start, a_start are conditionally
activated. If an input is activated, the corresponding flange property
is initialized with the input value at start time.
</p>

<p>
For example, if "use_phi_start = true", then flange.phi is inialized
with the value of the input signal "phi_start" at the start time.
</p>

<p>
Additionally, it is optionally possible to define the "StateSelect"
attribute of the flange angle and the flange speed via paramater
"stateSelection".
</p>

<p>
This component is especially useful when the initial values of a flange
shall be set according to reference signals of a controller that are
provided via a signal bus.
</p>

<pre></PRE>
<H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>use_phi_start</TD><TD>true</TD><TD>= true, if initial angle is defined by input phi_start, otherwise not initialized</TD></TR>
<TR><TD>Boolean</TD><TD>use_w_start</TD><TD>true</TD><TD>= true, if initial speed is defined by input w_start, otherwise not initialized</TD></TR>
<TR><TD>Boolean</TD><TD>use_a_start</TD><TD>true</TD><TD>= true, if initial angular acceleration is defined by input a_start, otherwise not initialized</TD></TR>
<TR><TD><A HREF="Modelica_Blocks_Types_StateSelection.html#f20e56826b4d9061teSelection.Temp"
>Temp</A></TD><TD>stateSelection</TD><TD>Modelica.Blocks.Types.StateS...</TD><TD>Priority to use flange angle and speed as states</TD></TR>
</TABLE>
<H3>Connectors</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>phi_start</TD><TD>Initial angle of flange</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>w_start</TD><TD>Initial speed of flange</TD></TR>
<TR><TD>input <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>RealInput</A></TD><TD>a_start</TD><TD>Initial angular acceleration of flange</TD></TR>
<TR><TD><A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Flange_b</A></TD><TD>flange</TD><TD>Flange that is initialized</TD></TR>
</TABLE>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> InitializeFlange <font color="darkgreen">
  &quot;Initializes a flange with pre-defined angle, speed and angular acceleration (usually, this is reference data from a control bus)&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_Blocks_Types_StateSelection.html#Modelica.Blocks.Types.StateSelection"
>Modelica.Blocks.Types.StateSelection</A>;
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon"
>Blocks.Interfaces.BlockIcon</A>;
  <font color="blue">parameter </font>Boolean use_phi_start = true <font color="darkgreen">
    &quot;= true, if initial angle is defined by input phi_start, otherwise not initialized&quot;</font>;
  <font color="blue">parameter </font>Boolean use_w_start = true <font color="darkgreen">
    &quot;= true, if initial speed is defined by input w_start, otherwise not initialized&quot;</font>;
  <font color="blue">parameter </font>Boolean use_a_start = true <font color="darkgreen">
    &quot;= true, if initial angular acceleration is defined by input a_start, otherwise not initialized&quot;</font>;

  <font color="blue">parameter </font><A HREF="Modelica_Blocks_Types_StateSelection.html#f20e56826b4d9061teSelection.Temp"
>Modelica.Blocks.Types.StateSelection.Temp</A> stateSelection=
            Modelica.Blocks.Types.StateSelection.Default <font color="darkgreen">
    &quot;Priority to use flange angle and speed as states&quot;</font>;

  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Blocks.Interfaces.RealInput</A> phi_start(<font color="blue">redeclare </font><font color="blue">type</font> SignalType =
        <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Modelica.SIunits.Angle</A>) <font color="blue">if </font>use_phi_start <font color="darkgreen">&quot;Initial angle of flange&quot;</font>;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Blocks.Interfaces.RealInput</A> w_start(<font color="blue">redeclare </font><font color="blue">type</font> SignalType =
        <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A>) <font color="blue">if </font>use_w_start <font color="darkgreen">
    &quot;Initial speed of flange&quot;</font>;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Blocks.Interfaces.RealInput</A> a_start(<font color="blue">redeclare </font><font color="blue">type</font> SignalType =
        <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>Modelica.SIunits.AngularAcceleration</A>) <font color="blue">if </font>use_a_start <font color="darkgreen">
    &quot;Initial angular acceleration of flange&quot;</font>;
  <A HREF="Modelica_Mechanics_Rotational_Interfaces.html#0dd23616c7e1b042erfaces.Flange_b"
>Interfaces.Flange_b</A> flange <font color="darkgreen">&quot;Flange that is initialized&quot;</font>;

  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Angle"
>Modelica.SIunits.Angle</A> phi_flange(stateSelect=
           <font color="blue">if </font>stateSelection==StateSelection.Never<font color="blue"> then </font>
              StateSelect.never<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Avoid<font color="blue"> then </font>
              StateSelect.avoid<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Default<font color="blue"> then </font>
              StateSelect.default<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Prefer<font color="blue"> then </font>
              StateSelect.prefer<font color="blue"> else </font>StateSelect.always) = flange.phi <font color="darkgreen">
    &quot;Flange angle&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_flange(stateSelect=
           <font color="blue">if </font>stateSelection==StateSelection.Never<font color="blue"> then </font>
              StateSelect.never<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Avoid<font color="blue"> then </font>
              StateSelect.avoid<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Default<font color="blue"> then </font>
              StateSelect.default<font color="blue"> else </font>
           <font color="blue">if </font>stateSelection==StateSelection.Prefer<font color="blue"> then </font>
              StateSelect.prefer<font color="blue"> else </font>StateSelect.always)=
        <font color="red">der</font>(phi_flange) <font color="darkgreen">&quot;= der(phi_flange)&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularAcceleration"
>SI.AngularAcceleration</A> a_flange=<font color="red">der</font>(w_flange) <font color="darkgreen">&quot;= der(w_flange)&quot;</font>;

<font color="blue">protected </font>
  <font color="blue">model</font> GetInputs <font color="darkgreen">
    &quot;Get enabled inputs and parameters of disabled inputs&quot;</font>
    <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon"
>Modelica.Blocks.Interfaces.BlockIcon</A>;
    <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> phi_start <font color="darkgreen">&quot;Start angle&quot;</font>;
    <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> w_start <font color="darkgreen">&quot;Start speed&quot;</font>;
    <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> a_start <font color="darkgreen">&quot;Start angular acceleration&quot;</font>;
  <font color="blue">end </font>GetInputs;
<font color="blue">protected </font>
  <A HREF="Modelica_Mechanics_Rotational.html#373da008fd4c1c2cFlange.GetInputs"
>GetInputs</A> getInputs;
<font color="blue">initial </font><font color="blue">equation </font>
  <font color="blue">if </font>use_phi_start<font color="blue"> then</font>
     phi_flange = getInputs.phi_start;
  <font color="blue">end if</font>;
  <font color="blue">if </font>use_w_start<font color="blue"> then</font>
     w_flange = getInputs.w_start;
  <font color="blue">end if</font>;
  <font color="blue">if </font>use_a_start<font color="blue"> then</font>
     a_flange = getInputs.a_start;
  <font color="blue">end if</font>;
<font color="blue">equation </font>
  <font color="red">connect</font>(phi_start, getInputs.phi_start);
  <font color="red">connect</font>(w_start, getInputs.w_start);
  <font color="red">connect</font>(a_start, getInputs.a_start);

  <font color="blue">if </font><font color="blue">not </font>use_phi_start<font color="blue"> then</font>
     getInputs.phi_start = 0;
  <font color="blue">end if</font>;
  <font color="blue">if </font><font color="blue">not </font>use_w_start<font color="blue"> then</font>
     getInputs.w_start = 0;
  <font color="blue">end if</font>;
  <font color="blue">if </font><font color="blue">not </font>use_a_start<font color="blue"> then</font>
     getInputs.a_start = 0;
  <font color="blue">end if</font>;

  flange.tau = 0;
<font color="blue">end </font>InitializeFlange;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE position_der<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="1b7a9c4ea9302495ove.position_der"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Move"
>Modelica.Mechanics.Rotational.Move</A>.position_der</H2>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> position_der
  annotation(derivative=<A HREF="Modelica_Mechanics_Rotational.html#0fbdfc1c261b9287ve.position_der2"
>position_der2</A>);
   <font color="blue">input </font>Real q_qd_qdd[3] <font color="darkgreen">&quot;Required values for position, speed, acceleration&quot;</font>;
   <font color="blue">input </font>Real dummy <font color="darkgreen">
    &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;</font>;
   <font color="blue">input </font>Real dummy_der;
   <font color="blue">output </font>Real qd;
<font color="blue">algorithm </font>
  qd :=q_qd_qdd[2];
<font color="blue">end </font>position_der;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE position_der2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="0fbdfc1c261b9287ve.position_der2"></A><A HREF="Modelica_Mechanics_Rotational.html#Modelica.Mechanics.Rotational.Move"
>Modelica.Mechanics.Rotational.Move</A>.position_der2</H2>
<H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> position_der2
   <font color="blue">input </font>Real q_qd_qdd[3] <font color="darkgreen">&quot;Required values for position, speed, acceleration&quot;</font>;
   <font color="blue">input </font>Real dummy <font color="darkgreen">
    &quot;Just to have one input signal that should be differentiated to avoid possible problems in the Modelica tool (is not used)&quot;</font>;
   <font color="blue">input </font>Real dummy_der;
   <font color="blue">input </font>Real dummy_der2;
   <font color="blue">output </font>Real qdd;
<font color="blue">algorithm </font>
  qdd :=q_qd_qdd[3];
<font color="blue">end </font>position_der2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE GetInputs<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Mechanics.Rotational.InitializeFlange.GetInputsI.png" ALT="Modelica.Mechanics.Rotational.InitializeFlange.GetInputs" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="373da008fd4c1c2cFlange.GetInputs"></A><A HREF="Modelica_Mechanics_Rotational.html#770f8c3f10ba9fe4InitializeFlange"
>Modelica.Mechanics.Rotational.InitializeFlange</A>.GetInputs</H2>
<B>Get enabled inputs and parameters of disabled inputs</B><p>
<IMG SRC="Modelica.Mechanics.Rotational.InitializeFlange.GetInputsD.png" ALT="Modelica.Mechanics.Rotational.InitializeFlange.GetInputs">
<H3>Modelica definition</H3>
<PRE>
<font color="blue">model</font> GetInputs <font color="darkgreen">
  &quot;Get enabled inputs and parameters of disabled inputs&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.BlockIcon"
>Modelica.Blocks.Interfaces.BlockIcon</A>;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> phi_start <font color="darkgreen">&quot;Start angle&quot;</font>;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> w_start <font color="darkgreen">&quot;Start speed&quot;</font>;
  <A HREF="Modelica_Blocks_Interfaces.html#Modelica.Blocks.Interfaces.RealInput"
>Modelica.Blocks.Interfaces.RealInput</A> a_start <font color="darkgreen">&quot;Start angular acceleration&quot;</font>;
<font color="blue">end </font>GetInputs;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Fri Sep 07 19:13:49 2007.
</address></BODY>
</HTML>
