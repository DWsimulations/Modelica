<HTML>
<HEAD>
<TITLE>Modelica.Blocks.Continuous.Internal.Filter.base</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Prototype low pass filters with cut-off frequency of 1 rad/s (other filters are derived by transformation from these base filters)&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal}
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE base<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.base"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter.html#Modelica.Blocks.Continuous.Internal.Filter"
>Modelica.Blocks.Continuous.Internal.Filter</A>.base</H2>
<B>Prototype low pass filters with cut-off frequency of 1 rad/s (other filters are derived by transformation from these base filters)</B>
<P>
<P><H3>Information</H3></P>
Extends from <A HREF="Modelica_Icons_Package.html#Modelica.Icons.Package"
>Modelica.Icons.Package</A> (Icon for standard packages).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping"
>CriticalDamping</A>
</TD><TD>Return base filter coefficients of CriticalDamping filter (= low pass filter with w_cut = 1 rad/s)</TD></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.base.Bessel" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base.Bessel"
>Bessel</A>
</TD><TD>Return base filter coefficients of Bessel filter (= low pass filter with w_cut = 1 rad/s)</TD></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth"
>Butterworth</A>
</TD><TD>Return base filter coefficients of Butterwort filter (= low pass filter with w_cut = 1 rad/s)</TD></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI"
>ChebyshevI</A>
</TD><TD>Return base filter coefficients of Chebyshev I filter (= low pass filter with w_cut = 1 rad/s)</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE CriticalDamping<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base"
>Modelica.Blocks.Continuous.Internal.Filter.base</A>.CriticalDamping</H2>
<B>Return base filter coefficients of CriticalDamping filter (= low pass filter with w_cut = 1 rad/s)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>&nbsp;</TD><TD>Order of filter</TD></TR>
<TR><TD>Boolean</TD><TD>normalized</TD><TD>true</TD><TD>= true, if amplitude at f_cut = -3db, otherwise unmodified filter</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[order]</TD><TD>Coefficients of real poles</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> CriticalDamping <font color="darkgreen">
  &quot;Return base filter coefficients of CriticalDamping filter (= low pass filter with w_cut = 1 rad/s)&quot;</font>

  <font color="blue">input </font>Integer order(min=1) <font color="darkgreen">&quot;Order of filter&quot;</font>;
  <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
    &quot;= true, if amplitude at f_cut = -3db, otherwise unmodified filter&quot;</font>;

  <font color="blue">output </font>Real cr[order] <font color="darkgreen">&quot;Coefficients of real poles&quot;</font>;
<font color="blue">protected </font>
  Real alpha=1.0 <font color="darkgreen">&quot;Frequency correction factor&quot;</font>;
  Real alpha2 <font color="darkgreen">&quot;= alpha*alpha&quot;</font>;
  Real den1[order] <font color="darkgreen">
    &quot;[p] coefficients of denominator first order polynomials (a*p + 1)&quot;</font>;
  Real den2[0,2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)&quot;</font>;
  Real c0[0] <font color="darkgreen">&quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  Real c1[0] <font color="darkgreen">&quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
<font color="blue">algorithm </font>
  <font color="blue">if </font>normalized<font color="blue"> then</font>
    <font color="darkgreen"> // alpha := sqrt(2^(1/order) - 1);</font>
     alpha :=<font color="red"> sqrt</font>(10^(3/10/order)-1);
  <font color="blue">else</font>
     alpha := 1.0;
  <font color="blue">end if</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:order<font color="blue"> loop</font>
     den1[i] := alpha;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Determine polynomials with highest power of s equal to one</font>
    (cr,c0,c1) :=
      <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne</font>(
      den1, den2);

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>CriticalDamping;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Bessel<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.base.Bessel"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base"
>Modelica.Blocks.Continuous.Internal.Filter.base</A>.Bessel</H2>
<B>Return base filter coefficients of Bessel filter (= low pass filter with w_cut = 1 rad/s)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>&nbsp;</TD><TD>Order of filter</TD></TR>
<TR><TD>Boolean</TD><TD>normalized</TD><TD>true</TD><TD>= true, if amplitude at f_cut = -3db, otherwise unmodified filter</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[mod(order, 2)]</TD><TD>Coefficient of real pole</TD></TR>
<TR><TD>Real</TD><TD>c0[integer(order/2)]</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1[integer(order/2)]</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> Bessel <font color="darkgreen">
  &quot;Return base filter coefficients of Bessel filter (= low pass filter with w_cut = 1 rad/s)&quot;</font>

  <font color="blue">input </font>Integer order(min=1) <font color="darkgreen">&quot;Order of filter&quot;</font>;
  <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
    &quot;= true, if amplitude at f_cut = -3db, otherwise unmodified filter&quot;</font>;

  <font color="blue">output </font>Real cr[<font color="red">mod</font>(order, 2)] <font color="darkgreen">&quot;Coefficient of real pole&quot;</font>;
  <font color="blue">output </font>Real c0[<font color="red">integer</font>(order/2)] <font color="darkgreen">
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">integer</font>(order/2)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
<font color="blue">protected </font>
  Integer n_den2=<font color="red">size</font>(c0, 1);
  Real alpha=1.0 <font color="darkgreen">&quot;Frequency correction factor&quot;</font>;
  Real alpha2 <font color="darkgreen">&quot;= alpha*alpha&quot;</font>;
  Real den1[<font color="red">size</font>(cr,1)] <font color="darkgreen">
    &quot;[p] coefficients of denominator first order polynomials (a*p + 1)&quot;</font>;
  Real den2[n_den2,2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)&quot;</font>;
<font color="blue">algorithm </font>
    (den1,den2,alpha) :=
      <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients</font>(
      order);
  <font color="blue">if </font><font color="blue">not </font>normalized<font color="blue"> then</font>
     alpha2 := alpha*alpha;
     <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
       den2[i, 1] := den2[i, 1]*alpha2;
       den2[i, 2] := den2[i, 2]*alpha;
     <font color="blue">end for</font>;
     <font color="blue">if </font><font color="red">size</font>(cr,1) == 1<font color="blue"> then</font>
       den1[1] := den1[1]*alpha;
     <font color="blue">end if</font>;
     <font color="blue">end if</font>;

  <font color="darkgreen">// Determine polynomials with highest power of s equal to one</font>
    (cr,c0,c1) :=
      <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne</font>(
      den1, den2);

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>Bessel;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Butterworth<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.base.Butterworth"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base"
>Modelica.Blocks.Continuous.Internal.Filter.base</A>.Butterworth</H2>
<B>Return base filter coefficients of Butterwort filter (= low pass filter with w_cut = 1 rad/s)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>&nbsp;</TD><TD>Order of filter</TD></TR>
<TR><TD>Boolean</TD><TD>normalized</TD><TD>true</TD><TD>= true, if amplitude at f_cut = -3db, otherwise unmodified filter</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[mod(order, 2)]</TD><TD>Coefficient of real pole</TD></TR>
<TR><TD>Real</TD><TD>c0[integer(order/2)]</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1[integer(order/2)]</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> Butterworth <font color="darkgreen">
  &quot;Return base filter coefficients of Butterwort filter (= low pass filter with w_cut = 1 rad/s)&quot;</font>

  <font color="blue">input </font>Integer order(min=1) <font color="darkgreen">&quot;Order of filter&quot;</font>;
  <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
    &quot;= true, if amplitude at f_cut = -3db, otherwise unmodified filter&quot;</font>;

  <font color="blue">output </font>Real cr[<font color="red">mod</font>(order, 2)] <font color="darkgreen">&quot;Coefficient of real pole&quot;</font>;
  <font color="blue">output </font>Real c0[<font color="red">integer</font>(order/2)] <font color="darkgreen">
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">integer</font>(order/2)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
<font color="blue">protected </font>
  Integer n_den2=<font color="red">size</font>(c0, 1);
  Real alpha=1.0 <font color="darkgreen">&quot;Frequency correction factor&quot;</font>;
  Real alpha2 <font color="darkgreen">&quot;= alpha*alpha&quot;</font>;
  Real den1[<font color="red">size</font>(cr,1)] <font color="darkgreen">
    &quot;[p] coefficients of denominator first order polynomials (a*p + 1)&quot;</font>;
  Real den2[n_den2,2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)&quot;</font>;
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
    den2[i, 1] := 1.0;
    den2[i, 2] := -2*<font color="red">Modelica.Math.cos</font>(pi*(0.5 + (i - 0.5)/order));
  <font color="blue">end for</font>;
  <font color="blue">if </font><font color="red">size</font>(cr,1) == 1<font color="blue"> then</font>
    den1[1] := 1.0;
  <font color="blue">end if</font>;

  <font color="darkgreen">/* Transformation of filter transfer function with &quot;new(p) = alpha*p&quot;
     in order that the filter transfer function has an amplitude of
     -3 db at the cutoff frequency
  */</font>
  <font color="darkgreen">/*
    if normalized then
      alpha := Internal.normalizationFactor(den1, den2);
      alpha2 := alpha*alpha;
      for i in 1:n_den2 loop
        den2[i, 1] := den2[i, 1]*alpha2;
        den2[i, 2] := den2[i, 2]*alpha;
      end for;
      if size(cr,1) == 1 then
        den1[1] := den1[1]*alpha;
      end if;
    end if;
  */</font>

  <font color="darkgreen">// Determine polynomials with highest power of s equal to one</font>
    (cr,c0,c1) :=
      <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne</font>(
      den1, den2);

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>Butterworth;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE ChebyshevI<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.base.ChebyshevI"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_base.html#Modelica.Blocks.Continuous.Internal.Filter.base"
>Modelica.Blocks.Continuous.Internal.Filter.base</A>.ChebyshevI</H2>
<B>Return base filter coefficients of Chebyshev I filter (= low pass filter with w_cut = 1 rad/s)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>&nbsp;</TD><TD>Order of filter</TD></TR>
<TR><TD>Real</TD><TD>A_ripple</TD><TD>0.5</TD><TD>Pass band ripple in [dB]</TD></TR>
<TR><TD>Boolean</TD><TD>normalized</TD><TD>true</TD><TD>= true, if amplitude at f_cut = -3db, otherwise unmodified filter</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[mod(order, 2)]</TD><TD>Coefficient of real pole</TD></TR>
<TR><TD>Real</TD><TD>c0[integer(order/2)]</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1[integer(order/2)]</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> ChebyshevI <font color="darkgreen">
  &quot;Return base filter coefficients of Chebyshev I filter (= low pass filter with w_cut = 1 rad/s)&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.*;

  <font color="blue">input </font>Integer order(min=1) <font color="darkgreen">&quot;Order of filter&quot;</font>;
  <font color="blue">input </font>Real A_ripple = 0.5 <font color="darkgreen">&quot;Pass band ripple in [dB]&quot;</font>;
  <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
    &quot;= true, if amplitude at f_cut = -3db, otherwise unmodified filter&quot;</font>;

  <font color="blue">output </font>Real cr[<font color="red">mod</font>(order, 2)] <font color="darkgreen">&quot;Coefficient of real pole&quot;</font>;
  <font color="blue">output </font>Real c0[<font color="red">integer</font>(order/2)] <font color="darkgreen">
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">integer</font>(order/2)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
<font color="blue">protected </font>
  Real epsilon;
  Real fac;
  Integer n_den2=<font color="red">size</font>(c0, 1);
  Real alpha=1.0 <font color="darkgreen">&quot;Frequency correction factor&quot;</font>;
  Real alpha2 <font color="darkgreen">&quot;= alpha*alpha&quot;</font>;
  Real den1[<font color="red">size</font>(cr,1)] <font color="darkgreen">
    &quot;[p] coefficients of denominator first order polynomials (a*p + 1)&quot;</font>;
  Real den2[n_den2,2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)&quot;</font>;
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
<font color="blue">algorithm </font>
    epsilon :=<font color="red"> sqrt</font>(10^(A_ripple/10) - 1);
    fac :=<font color="red"> asinh</font>(1/epsilon)/order;

    <font color="blue">if </font><font color="red">size</font>(cr,1) == 0<font color="blue"> then</font>
       <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
          den2[i,1] :=1/(<font color="red">cosh</font>(fac)^2 -<font color="red"> cos</font>((2*i - 1)*pi/(2*order))^2);
          den2[i,2] :=2*den2[i, 1]*<font color="red">sinh</font>(fac)*<font color="red">cos</font>((2*i - 1)*pi/(2*order));
       <font color="blue">end for</font>;
    <font color="blue">else</font>
       den1[1] := 1/<font color="red">sinh</font>(fac);
       <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
          den2[i,1] :=1/(<font color="red">cosh</font>(fac)^2 -<font color="red"> cos</font>(i*pi/order)^2);
          den2[i,2] :=2*den2[i, 1]*<font color="red">sinh</font>(fac)*<font color="red">cos</font>(i*pi/order);
       <font color="blue">end for</font>;
    <font color="blue">end if</font>;

  <font color="darkgreen">  /* Transformation of filter transfer function with &quot;new(p) = alpha*p&quot;
       in order that the filter transfer function has an amplitude of
       -3 db at the cutoff frequency
    */</font>
    <font color="blue">if </font>normalized<font color="blue"> then</font>
      alpha :=
        <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor</font>(
        den1, den2);
      alpha2 := alpha*alpha;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
        den2[i, 1] := den2[i, 1]*alpha2;
        den2[i, 2] := den2[i, 2]*alpha;
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="red">size</font>(cr,1) == 1<font color="blue"> then</font>
        den1[1] := den1[1]*alpha;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

  <font color="darkgreen">// Determine polynomials with highest power of s equal to one</font>
    (cr,c0,c1) :=
      <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne</font>(
      den1, den2);

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>ChebyshevI;
</PRE>
<HR>
<address><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:27:36 2010.
</address></BODY>
</HTML>
