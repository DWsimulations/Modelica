<HTML>
<HEAD>
<TITLE>Modelica.Blocks.Continuous.Internal.Filter.coefficients</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Filter coefficients&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal}
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE coefficients<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.coefficients"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter.html#Modelica.Blocks.Continuous.Internal.Filter"
>Modelica.Blocks.Continuous.Internal.Filter</A>.coefficients</H2>
<B>Filter coefficients</B>
<P>
<P><H3>Information</H3></P>
Extends from <A HREF="Modelica_Icons_Package.html#Modelica.Icons.Package"
>Modelica.Icons.Package</A> (Icon for standard packages).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass"
>lowPass</A>
</TD><TD>Return low pass filter coefficients at given cut-off frequency</TD></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass"
>highPass</A>
</TD><TD>Return high pass filter coefficients at given cut-off frequency</TD></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass"
>bandPass</A>
</TD><TD>Return band pass filter coefficients at given cut-off frequency</TD></TR>
<TR><TD><IMG SRC="Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDampingS.png" ALT="Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop"
>bandStop</A>
</TD><TD>Return band stop filter coefficients at given cut-off frequency</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE lowPass<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients"
>Modelica.Blocks.Continuous.Internal.Filter.coefficients</A>.lowPass</H2>
<B>Return low pass filter coefficients at given cut-off frequency</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of real poles</TD></TR>
<TR><TD>Real</TD><TD>c0_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1_in[size(c0_in, 1)]</TD><TD>&nbsp;</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_cut</TD><TD>&nbsp;</TD><TD>Cut-off frequency [Hz]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[size(cr_in, 1)]</TD><TD>Coefficient of real pole</TD></TR>
<TR><TD>Real</TD><TD>c0[size(c0_in, 1)]</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1[size(c0_in, 1)]</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> lowPass <font color="darkgreen">
  &quot;Return low pass filter coefficients at given cut-off frequency&quot;</font>

  <font color="blue">input </font>Real cr_in[:] <font color="darkgreen">&quot;Coefficients of real poles&quot;</font>;
  <font color="blue">input </font>Real c0_in[:] <font color="darkgreen">&quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font>Real c1_in[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_cut <font color="darkgreen">&quot;Cut-off frequency&quot;</font>;

  <font color="blue">output </font>Real cr[<font color="red">size</font>(cr_in,1)] <font color="darkgreen">&quot;Coefficient of real pole&quot;</font>;
  <font color="blue">output </font>Real c0[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;

<font color="blue">protected </font>
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_cut=2*pi*f_cut <font color="darkgreen">&quot;Cut-off angular frequency&quot;</font>;
  Real w_cut2=w_cut*w_cut;

<font color="blue">algorithm </font>
  <font color="red">assert</font>(f_cut &gt; 0, &quot;Cut-off frequency f_cut must be positive&quot;);

  <font color="darkgreen">/* Change filter coefficients according to transformation new(s) = s/w_cut
     s + cr           -&gt; (s/w) + cr              = (s + w*cr)/w
     s^2 + c1*s + c0  -&gt; (s/w)^2 + c1*(s/w) + c0 = (s^2 + (c1*w)*s + (c0*w^2))/w^2
  */</font>
  cr := w_cut*cr_in;
  c1 := w_cut*c1_in;
  c0 := w_cut2*c0_in;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>lowPass;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE highPass<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.coefficients.highPass"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients"
>Modelica.Blocks.Continuous.Internal.Filter.coefficients</A>.highPass</H2>
<B>Return high pass filter coefficients at given cut-off frequency</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of real poles</TD></TR>
<TR><TD>Real</TD><TD>c0_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1_in[size(c0_in, 1)]</TD><TD>&nbsp;</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_cut</TD><TD>&nbsp;</TD><TD>Cut-off frequency [Hz]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[size(cr_in, 1)]</TD><TD>Coefficient of real pole</TD></TR>
<TR><TD>Real</TD><TD>c0[size(c0_in, 1)]</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1[size(c0_in, 1)]</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> highPass <font color="darkgreen">
  &quot;Return high pass filter coefficients at given cut-off frequency&quot;</font>

  <font color="blue">input </font>Real cr_in[:] <font color="darkgreen">&quot;Coefficients of real poles&quot;</font>;
  <font color="blue">input </font>Real c0_in[:] <font color="darkgreen">&quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font>Real c1_in[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_cut <font color="darkgreen">&quot;Cut-off frequency&quot;</font>;

  <font color="blue">output </font>Real cr[<font color="red">size</font>(cr_in,1)] <font color="darkgreen">&quot;Coefficient of real pole&quot;</font>;
  <font color="blue">output </font>Real c0[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;

<font color="blue">protected </font>
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_cut=2*pi*f_cut <font color="darkgreen">&quot;Cut-off angular frequency&quot;</font>;
  Real w_cut2=w_cut*w_cut;

<font color="blue">algorithm </font>
  <font color="red">assert</font>(f_cut &gt; 0, &quot;Cut-off frequency f_cut must be positive&quot;);

  <font color="darkgreen">/* Change filter coefficients according to transformation: new(s) = 1/s
        1/(s + cr)          -&gt; 1/(1/s + cr)                = (1/cr)*s / (s + (1/cr))
        1/(s^2 + c1*s + c0) -&gt; 1/((1/s)^2 + c1*(1/s) + c0) = (1/c0)*s^2 / (s^2 + (c1/c0)*s + 1/c0)

     Check whether transformed roots are also conjugate complex:
        c0 - c1^2/4 &gt; 0  -&gt; (1/c0) - (c1/c0)^2 / 4
                            = (c0 - c1^2/4) / c0^2 &gt; 0
        It is therefore guaranteed that the roots remain conjugate complex

     Change filter coefficients according to transformation new(s) = s/w_cut
        s + 1/cr                -&gt; (s/w) + 1/cr                   = (s + w/cr)/w
        s^2 + (c1/c0)*s + 1/c0  -&gt; (s/w)^2 + (c1/c0)*(s/w) + 1/c0 = (s^2 + (w*c1/c0)*s + (w^2/c0))/w^2
  */</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(cr_in,1)<font color="blue"> loop</font>
     cr[i] := w_cut/cr_in[i];
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c0_in,1)<font color="blue"> loop</font>
     c0[i] := w_cut2/c0_in[i];
     c1[i] := w_cut*c1_in[i]/c0_in[i];
  <font color="blue">end for</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>highPass;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE bandPass<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandPass"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients"
>Modelica.Blocks.Continuous.Internal.Filter.coefficients</A>.bandPass</H2>
<B>Return band pass filter coefficients at given cut-off frequency</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of real poles</TD></TR>
<TR><TD>Real</TD><TD>c0_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1_in[size(c0_in, 1)]</TD><TD>&nbsp;</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_min</TD><TD>&nbsp;</TD><TD>Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db) [Hz]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_max</TD><TD>&nbsp;</TD><TD>Upper band frequency [Hz]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[0]</TD><TD>Coefficient of real pole</TD></TR>
<TR><TD>Real</TD><TD>c0[size(cr_in, 1) + 2*size(c0_in, 1)]</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1[size(cr_in, 1) + 2*size(c0_in, 1)]</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>cn</TD><TD>Numerator coefficient of the PT2 terms</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> bandPass <font color="darkgreen">
  &quot;Return band pass filter coefficients at given cut-off frequency&quot;</font>

  <font color="blue">input </font>Real cr_in[:] <font color="darkgreen">&quot;Coefficients of real poles&quot;</font>;
  <font color="blue">input </font>Real c0_in[:] <font color="darkgreen">&quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font>Real c1_in[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_min <font color="darkgreen">
    &quot;Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db)&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_max <font color="darkgreen">&quot;Upper band frequency&quot;</font>;

  <font color="blue">output </font>Real cr[0] <font color="darkgreen">&quot;Coefficient of real pole&quot;</font>;
  <font color="blue">output </font>Real c0[<font color="red">size</font>(cr_in,1) + 2*<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">size</font>(cr_in,1) + 2*<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real cn <font color="darkgreen">&quot;Numerator coefficient of the PT2 terms&quot;</font>;
<font color="blue">protected </font>
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f0 =<font color="red"> sqrt</font>(f_min*f_max);
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_cut=2*pi*f0 <font color="darkgreen">&quot;Cut-off angular frequency&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_band = (f_max - f_min) / f0;
  Real w_cut2=w_cut*w_cut;
  Real c;
  Real alpha;
  Integer j;
<font color="blue">algorithm </font>
  <font color="red">assert</font>(f_min &gt; 0<font color="blue"> and </font>f_min &lt; f_max, &quot;Band frequencies f_min and f_max are wrong&quot;);

  <font color="darkgreen">  /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -&gt; 1/(s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -&gt; 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 / ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -&gt; c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -&gt; equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

     Check whether roots remain conjugate complex
        c0 - (c1/2)^2 &gt; 0:    1/alpha^2 - (c/alpha)^2/4
                              = 1/alpha^2*(1 - c^2/4)    -&gt; not possible to figure this out

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        w_band*s/(s^2 + c1*s + c0)  -&gt; w_band*(s/w)/((s/w)^2 + c1*(s/w) + c0 =
                                       (w_band/w)*s/(s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                       (w_band*w)*s/(s^2 + (c1*w)*s + (c0*w^2))
    */</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(cr_in,1)<font color="blue"> loop</font>
       c1[i] := w_cut*cr_in[i]*w_band;
       c0[i] := w_cut2;
    <font color="blue">end for</font>;

    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c1_in,1)<font color="blue"> loop</font>
      alpha :=
        <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha</font>(
              c1_in[i],
              c0_in[i],
              w_band);
       c       := c1_in[i]*w_band / (alpha + 1/alpha);
       j       :=<font color="red"> size</font>(cr_in,1) + 2*i - 1;
       c1[j]   := w_cut*c/alpha;
       c1[j+1] := w_cut*c*alpha;
       c0[j]   := w_cut2/alpha^2;
       c0[j+1] := w_cut2*alpha^2;
    <font color="blue">end for</font>;

    cn :=w_band*w_cut;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>bandPass;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE bandStop<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Blocks.Continuous.Internal.Filter.coefficients.bandStop"></A><A HREF="Modelica_Blocks_Continuous_Internal_Filter_coefficients.html#Modelica.Blocks.Continuous.Internal.Filter.coefficients"
>Modelica.Blocks.Continuous.Internal.Filter.coefficients</A>.bandStop</H2>
<B>Return band stop filter coefficients at given cut-off frequency</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of real poles</TD></TR>
<TR><TD>Real</TD><TD>c0_in[:]</TD><TD>&nbsp;</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1_in[size(c0_in, 1)]</TD><TD>&nbsp;</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_min</TD><TD>&nbsp;</TD><TD>Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db) [Hz]</TD></TR>
<TR><TD><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_max</TD><TD>&nbsp;</TD><TD>Upper band frequency [Hz]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cr[0]</TD><TD>Coefficient of real pole</TD></TR>
<TR><TD>Real</TD><TD>c0[size(cr_in, 1) + 2*size(c0_in, 1)]</TD><TD>Coefficients of s^0 term if conjugate complex pole</TD></TR>
<TR><TD>Real</TD><TD>c1[size(cr_in, 1) + 2*size(c0_in, 1)]</TD><TD>Coefficients of s^1 term if conjugate complex pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> bandStop <font color="darkgreen">
  &quot;Return band stop filter coefficients at given cut-off frequency&quot;</font>

  <font color="blue">input </font>Real cr_in[:] <font color="darkgreen">&quot;Coefficients of real poles&quot;</font>;
  <font color="blue">input </font>Real c0_in[:] <font color="darkgreen">&quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font>Real c1_in[<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_min <font color="darkgreen">
    &quot;Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db)&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_max <font color="darkgreen">&quot;Upper band frequency&quot;</font>;

  <font color="blue">output </font>Real cr[0] <font color="darkgreen">&quot;Coefficient of real pole&quot;</font>;
  <font color="blue">output </font>Real c0[<font color="red">size</font>(cr_in,1) + 2*<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^0 term if conjugate complex pole&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">size</font>(cr_in,1) + 2*<font color="red">size</font>(c0_in,1)] <font color="darkgreen">
    &quot;Coefficients of s^1 term if conjugate complex pole&quot;</font>;
<font color="blue">protected </font>
  <font color="blue">constant </font>Real pi=Modelica.Constants.pi;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f0 =<font color="red"> sqrt</font>(f_min*f_max);
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_cut=2*pi*f0 <font color="darkgreen">&quot;Cut-off angular frequency&quot;</font>;
  <A HREF="Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_band = (f_max - f_min) / f0;
  Real w_cut2=w_cut*w_cut;
  Real c;
  Real ww;
  Real alpha;
  Integer j;
<font color="blue">algorithm </font>
  <font color="red">assert</font>(f_min &gt; 0<font color="blue"> and </font>f_min &lt; f_max, &quot;Band frequencies f_min and f_max are wrong&quot;);

  <font color="darkgreen">  /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -&gt; 1/(s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -&gt; 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 / ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -&gt; c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -&gt; equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

       The band stop filter is derived from the low pass filter by
       the transformation new(s) = w/( (s + 1/s) )   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       cr/(s + cr)         -&gt; 1/( w/(s + 1/s) ) + cr)
                              = (s^2 + 1) / (s^2 + (w/cr)*s + 1)

       c0/(s^2 + c1*s + c0) -&gt; c0/( w^2/(s + 1/s)^2 + c1*w/(s + 1/s) + c0 )
                               = c0*(s^2 + 1)^2 / (s^4 + c1*w*s^3/c0 + (2+w^2/b)*s^2 + c1*w*s/c0 + 1)

                               Assume the following description with PT2:
                               = c0*(s^2 + 1)^2 / ( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                                    (s^2 + s*(c*alpha) + alpha^2) )
                               = c0*(s^2 + 1)^2 / (  s^4 + c*(alpha + 1/alpha)*s^3
                                                         + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                         + c*(alpha + 1/alpha)*p + 1 )

                            and therefore:
                              c*(alpha + 1/alpha) = c1*w/b         -&gt; c = c1*w/(c0*(alpha + 1/alpha))
                              alpha^2 + 1/alpha^2 + c^2 = 2+w^2/c0 -&gt; equation to determine alpha
                              alpha^4 + 1 + (c1*w/c0*alpha^2)^2/(1+alpha^2)^2 = (2+w^2/c0)*alpha^2
                              or z = alpha^2
                              z^2 + (c1*w/c0*z)^2/(1+z)^2 - (2+w^2/c0)*z + 1 = 0

                            same as:  ww = w/c0
                              z^2 + (c1*ww*z)^2/(1+z)^2 - (2+c0*ww)*z + 1 = 0  -&gt; same equation as for BandPass

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        c0*(s^2+1)(s^2 + c1*s + c0)  -&gt; c0*((s/w)^2 + 1) / ((s/w)^2 + c1*(s/w) + c0 =
                                        c0/w^2*(s^2 + w^2) / (s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                        (s^2 + c0*w^2) / (s^2 + (c1*w)*s + (c0*w^2))
    */</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(cr_in,1)<font color="blue"> loop</font>
       c1[i] := w_cut*w_band/cr_in[i];
       c0[i] := w_cut2;
    <font color="blue">end for</font>;

    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c1_in,1)<font color="blue"> loop</font>
       ww      := w_band/c0_in[i];
      alpha :=
        <font color="red">Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha</font>(
              c1_in[i],
              c0_in[i],
              ww);
       c       := c1_in[i]*ww / (alpha + 1/alpha);
       j       :=<font color="red"> size</font>(cr_in,1) + 2*i - 1;
       c1[j]   := w_cut*c/alpha;
       c1[j+1] := w_cut*c*alpha;
       c0[j]   := w_cut2/alpha^2;
       c0[j+1] := w_cut2*alpha^2;
    <font color="blue">end for</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>bandStop;
</PRE>
<HR>
<address><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:27:36 2010.
</address></BODY>
</HTML>
