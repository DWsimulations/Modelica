<HTML>
<HEAD>
<TITLE>Modelica.ComplexMath.Vectors</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Library of functions operating on complex vectors&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal}
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Vectors<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.ComplexMath.Vectors"></A><A HREF="Modelica_ComplexMath.html#Modelica.ComplexMath"
>Modelica.ComplexMath</A>.Vectors</H2>
<B>Library of functions operating on complex vectors</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This library provides functions operating on vectors
of Complex numbers.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons_Package.html#Modelica.Icons.Package"
>Modelica.Icons.Package</A> (Icon for standard packages).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.ComplexMath.sinS.png" ALT="Modelica.ComplexMath.Vectors.norm" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors.norm"
>norm</A>
</TD><TD>Returns the p-norm of a complex vector</TD></TR>
<TR><TD><IMG SRC="Modelica.ComplexMath.sinS.png" ALT="Modelica.ComplexMath.Vectors.length" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors.length"
>length</A>
</TD><TD>Return length of a complex vector</TD></TR>
<TR><TD><IMG SRC="Modelica.ComplexMath.sinS.png" ALT="Modelica.ComplexMath.Vectors.normalize" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors.normalize"
>normalize</A>
</TD><TD>Return normalized complex vector such that length = 1 and prevent zero-division for zero vector</TD></TR>
<TR><TD><IMG SRC="Modelica.ComplexMath.Vectors.reverseS.png" ALT="Modelica.ComplexMath.Vectors.reverse" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors.reverse"
>reverse</A>
</TD><TD>Reverse vector elements (e.g., v[1] becomes last element)</TD></TR>
<TR><TD><IMG SRC="Modelica.ComplexMath.Vectors.sortS.png" ALT="Modelica.ComplexMath.Vectors.sort" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors.sort"
>sort</A>
</TD><TD>Sort elements of complex vector</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE norm<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.ComplexMath.Vectors.norm"></A><A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors"
>Modelica.ComplexMath.Vectors</A>.norm</H2>
<B>Returns the p-norm of a complex vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>norm</b>(v);
Vectors.<b>norm</b>(v,p=2);   // 1 &le; p &le; &#8734;
</pre></blockquote>

<h4>Description</h4>
<p>
The function call "<code>Vectors.<b>norm</b>(v)</code>" returns the
<b>Euclidean norm</b> "<code>sqrt(v*v)</code>" of vector v.
With the optional
second argument "p", any other p-norm can be computed:
</p>
<center>
<IMG src="../Resources/Images/Math/Vectors/vectorNorm.png" ALT="function Vectors.norm">
</center>
<p>
Besides the Euclidean norm (p=2), also the 1-norm and the
infinity-norm are sometimes used:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><b>1-norm</b></td>
      <td>= sum(abs(v))</td>
      <td><b>norm</b>(v,1)</td>
  </tr>
  <tr><td><b>2-norm</b></td>
      <td>= sqrt(v*v)</td>
      <td><b>norm</b>(v) or <b>norm</b>(v,2)</td>
  </tr>
  <tr><td><b>infinity-norm</b></td>
      <td>= max(abs(v))</td>
      <td><b>norm</b>(v,Modelica.Constants.<b>inf</b>)</td>
  </tr>
</table>
<p>
Note, for any vector norm the following inequality holds:
</p>
<blockquote><pre>
<b>norm</b>(v1+v2,p) &le; <b>norm</b>(v1,p) + <b>norm</b>(v2,p)
</pre></blockquote>

<h4>Example</h4>
<blockquote><pre>
  v = {2, -4, -2, -1};
  <b>norm</b>(v,1);    // = 9
  <b>norm</b>(v,2);    // = 5
  <b>norm</b>(v);      // = 5
  <b>norm</b>(v,10.5); // = 4.00052597412635
  <b>norm</b>(v,Modelica.Constants.inf);  // = 4
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm"
>Matrices.norm</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>v[:]</TD><TD>&nbsp;</TD><TD>Vector</TD></TR>
<TR><TD>Real</TD><TD>p</TD><TD>2</TD><TD>Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>p-norm of vector v</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> norm <font color="darkgreen">&quot;Returns the p-norm of a complex vector&quot;</font>
  <font color="blue">input </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> v[:] <font color="darkgreen">&quot;Vector&quot;</font>;
  <font color="blue">input </font>Real p(min=1) = 2 <font color="darkgreen">
    &quot;Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)&quot;</font>;
  <font color="blue">output </font>Real result <font color="darkgreen">&quot;p-norm of vector v&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font>p == 2<font color="blue"> then</font>
    result:=<font color="red"> sqrt</font>(<font color="red">sum</font>(v[i].re^2 + v[i].im^2 <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(v,1)));
  <font color="blue">elseif </font>p == Modelica.Constants.inf<font color="blue"> then</font>
    result:=<font color="red"> ComplexMath.&#39;abs&#39;</font>(<font color="red">ComplexMath.&#39;max&#39;</font>(v));
  <font color="blue">elseif </font>p == 1<font color="blue"> then</font>
    result:=<font color="red"> sum</font>(<font color="red">ComplexMath.&#39;abs&#39;</font>(v[i]) <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(v,1));
  <font color="blue">else</font>
    result:=(<font color="red">sum</font>(<font color="red">ComplexMath.&#39;abs&#39;</font>(v[i])^p <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(v, 1)))^(1/p);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>norm;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE length<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.ComplexMath.Vectors.length"></A><A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors"
>Modelica.ComplexMath.Vectors</A>.length</H2>
<B>Return length of a complex vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>length</b>(v);
</pre></blockquote>

<h4>Description</h4>

<p>
The function call "<code>Vectors.<b>length</b>(v)</code>" returns the
<b>Euclidean length</b> "<code>sqrt(v*v)</code>" of vector v.
The function call is equivalent to Vectors.norm(v). The advantage of
length(v) over norm(v)"is that function length(..) is implemented
in one statement and therefore the function is usually automatically
inlined. Further symbolic processing is therefore possible, which is
not the case with function norm(..).
</p>

<h4>Example</h4>
<blockquote><pre>
  v = {2, -4, -2, -1};
  <b>length</b>(v);  // = 5
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_Math_Vectors.html#Modelica.Math.Vectors.norm"
>Vectors.norm</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>v[:]</TD><TD>&nbsp;</TD><TD>Vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>Length of vector v</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> length <font color="darkgreen">&quot;Return length of a complex vector&quot;</font>
  <font color="blue">input </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> v[:] <font color="darkgreen">&quot;Vector&quot;</font>;
  <font color="blue">output </font>Real result <font color="darkgreen">&quot;Length of vector v&quot;</font>;

<font color="blue">algorithm </font>
  result :=<font color="red"> sqrt</font>(<font color="red">sum</font>({v[i].re^2 + v[i].im^2 <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(v,1)}));
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>length;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE normalize<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.ComplexMath.Vectors.normalize"></A><A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors"
>Modelica.ComplexMath.Vectors</A>.normalize</H2>
<B>Return normalized complex vector such that length = 1 and prevent zero-division for zero vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Vectors.<b>normalize</b>(v);
Vectors.<b>normalize</b>(v,eps=100*Modelica.Constants.eps);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call "<code>Vectors.<b>normalize</b>(v)</code>" returns the
<b>unit vector</b> "<code>v/length(v)</code>" of vector v.
If length(v) is close to zero (more precisely, if length(v) &lt; eps),
v is returned in order to avoid
a division by zero. For many applications this is useful, because
often the unit vector <b>e</b> = <b>v</b>/length(<b>v</b>) is used to compute
a vector x*<b>e</b>, where the scalar x is in the order of length(<b>v</b>),
i.e., x*<b>e</b> is small, when length(<b>v</b>) is small and then
it is fine to replace <b>e</b> by <b>v</b> to avoid a division by zero.
</p>
<p>
Since the function is implemented in one statement,
it is usually inlined and therefore symbolic processing is
possible.
</p>

<h4>Example</h4>
<blockquote><pre>
  <b>normalize</b>({1,2,3});  // = {0.267, 0.534, 0.802}
  <b>normalize</b>({0,0,0});  // = {0,0,0}
</pre></blockquote>

<h4>See also</h4>
<p>
<A HREF="Modelica_Math_Vectors.html#Modelica.Math.Vectors.length"
>Vectors.length</a>
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>v[:]</TD><TD>&nbsp;</TD><TD>Vector</TD></TR>
<TR><TD>Real</TD><TD>eps</TD><TD>100*Modelica.Constants.eps</TD><TD>if |v| &lt; eps then result = v</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>result[size(v, 1)]</TD><TD>Input vector v normalized to length=1</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> normalize <font color="darkgreen">
  &quot;Return normalized complex vector such that length = 1 and prevent zero-division for zero vector&quot;</font>
  <font color="blue">input </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> v[:] <font color="darkgreen">&quot;Vector&quot;</font>;
  <font color="blue">input </font>Real eps = 100*Modelica.Constants.eps <font color="darkgreen">&quot;if |v| &lt; eps then result = v&quot;</font>;
  <font color="blue">output </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> result[<font color="red">size</font>(v, 1)] <font color="darkgreen">&quot;Input vector v normalized to length=1&quot;</font>;

<font color="blue">protected </font>
  Real length_v =<font color="red"> length</font>(v);
<font color="blue">algorithm </font>
  <font color="blue">if </font>length_v &gt;= eps<font color="blue"> then</font>
     <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(v,1)<font color="blue"> loop</font>
         result[i] :=v[i].re/length_v + (v[i].im/length_v)*j;
     <font color="blue">end for</font>;
  <font color="blue">else</font>
     result :=v;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>normalize;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reverse<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.ComplexMath.Vectors.reverseI.png" ALT="Modelica.ComplexMath.Vectors.reverse" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.ComplexMath.Vectors.reverse"></A><A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors"
>Modelica.ComplexMath.Vectors</A>.reverse</H2>
<B>Reverse vector elements (e.g., v[1] becomes last element)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>Vectors.<b>reverse</b>(v);</pre></blockquote>
<h4>Description</h4>
The function call &quot;<code>Vectors.<b>reverse</b>(v)</code>&quot; returns the complex vector elements in reverse order.
<h4>Example</h4>
<blockquote><pre>  <b>reverse</b>({1,2,3,4});  // = {4,3,2,1}</pre></blockquote>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>v[:]</TD><TD>&nbsp;</TD><TD>Vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>result[size(v, 1)]</TD><TD>Elements of vector v in reversed order</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> reverse <font color="darkgreen">
  &quot;Reverse vector elements (e.g., v[1] becomes last element)&quot;</font>
<font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">input </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> v[:] <font color="darkgreen">&quot;Vector&quot;</font>;
  <font color="blue">output </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> result[<font color="red">size</font>(v, 1)] <font color="darkgreen">&quot;Elements of vector v in reversed order&quot;</font>;

<font color="blue">algorithm </font>
  result := {v[<font color="blue">end</font>-i+1] <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(v,1)};
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>reverse;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sort<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.ComplexMath.Vectors.sort"></A><A HREF="Modelica_ComplexMath_Vectors.html#Modelica.ComplexMath.Vectors"
>Modelica.ComplexMath.Vectors</A>.sort</H2>
<B>Sort elements of complex vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           sorted_v = Vectors.<b>sort</b>(v);
(sorted_v, indices) = Vectors.<b>sort</b>(v, ascending=true);
</pre></blockquote>

<h4>Description</h4>
<p>
Function <b>sort</b>(..) sorts a Real vector v
in ascending order and returns the result in sorted_v.
If the optional argument "ascending" is <b>false</b>, the vector
is sorted in descending order. In the optional second
output argument the indices of the sorted vector with respect
to the original vector are given, such that sorted_v = v[indices].
</p>

<h4>Example</h4>
<blockquote><pre>
  (v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
       -> v2 = {-1, 2, 3, 6, 8}
          i2 = {1, 5, 3, 4, 2}
</pre></blockquote>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>v[:]</TD><TD>&nbsp;</TD><TD>Vector to be sorted</TD></TR>
<TR><TD>Boolean</TD><TD>ascending</TD><TD>true</TD><TD>= true if ascending order, otherwise descending order</TD></TR>
<TR><TD>Boolean</TD><TD>sortFrequency</TD><TD>true</TD><TD>= true, if sorting is first for imaginary then for real value; = false, if sorting is for absolute value</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A></TD><TD>sorted_v[size(v, 1)]</TD><TD>Sorted vector</TD></TR>
<TR><TD>Integer</TD><TD>indices[size(v, 1)]</TD><TD>sorted_v = v[indices]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> sort <font color="darkgreen">&quot;Sort elements of complex vector&quot;</font>
  <font color="blue">input </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> v[:] <font color="darkgreen">&quot;Vector to be sorted&quot;</font>;
  <font color="blue">input </font>Boolean ascending = true <font color="darkgreen">
    &quot;= true if ascending order, otherwise descending order&quot;</font>;
  <font color="blue">input </font>Boolean sortFrequency=true <font color="darkgreen">
    &quot;= true, if sorting is first for imaginary then for real value; = false, if sorting is for absolute value&quot;</font>;
  <font color="blue">output </font><A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> sorted_v[<font color="red">size</font>(v,1)] = v <font color="darkgreen">&quot;Sorted vector&quot;</font>;
  <font color="blue">output </font>Integer indices[<font color="red">size</font>(v,1)] = 1:<font color="red">size</font>(v,1) <font color="darkgreen">&quot;sorted_v = v[indices]&quot;</font>;

  <font color="darkgreen">/* shellsort algorithm; should be improved later */</font>
<font color="blue">protected </font>
  Integer gap;
  Integer i;
  Integer j;
  <A HREF="../../../Modelica/Library/help/Complex.html#Complex"
>Complex</A> wv;
  Integer wi;
  Integer nv =<font color="red"> size</font>(v,1);
  Boolean swap;
  Integer k1;
  Integer k2;
<font color="blue">algorithm </font>
  gap :=<font color="red"> div</font>(nv,2);

  <font color="blue">while </font>gap &gt; 0<font color="blue"> loop</font>
     i := gap;
     <font color="blue">while </font>i &lt; nv<font color="blue"> loop</font>
        j := i-gap;
        <font color="blue">if </font>j&gt;=0<font color="blue"> then</font>
           k1 := j+1;
           k2 := j + gap + 1;
           <font color="blue">if </font>sortFrequency<font color="blue"> then</font>
              <font color="blue">if </font>ascending<font color="blue"> then</font>
                 swap :=<font color="red"> abs</font>(sorted_v[k1].im) &gt;<font color="red">  abs</font>(sorted_v[k2].im)<font color="blue"> or </font>
                         <font color="red">abs</font>(sorted_v[k1].im) ==<font color="red"> abs</font>(sorted_v[k2].im)<font color="blue"> and </font>
                         (sorted_v[k1].re  &gt; sorted_v[k2].re<font color="blue"> or </font>
                          sorted_v[k1].re  == sorted_v[k2].re<font color="blue"> and </font>sorted_v[k1].im &lt; sorted_v[k2].im);
              <font color="blue">else</font>
                 swap :=<font color="red"> abs</font>(sorted_v[k1].im) &lt;<font color="red">  abs</font>(sorted_v[k2].im)<font color="blue"> or </font>
                         <font color="red">abs</font>(sorted_v[k1].im) ==<font color="red"> abs</font>(sorted_v[k2].im)<font color="blue"> and </font>
                         (sorted_v[k1].re  &lt; sorted_v[k2].re<font color="blue"> or </font>
                          sorted_v[k1].re  == sorted_v[k2].re<font color="blue"> and </font>sorted_v[k1].im &lt; sorted_v[k2].im);
              <font color="blue">end if</font>;
           <font color="blue">else</font>
              <font color="blue">if </font>ascending<font color="blue"> then</font>
                 swap :=<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k1]) &gt;<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k2]);
              <font color="blue">else</font>
                 swap :=<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k1]) &lt;<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k2]);
              <font color="blue">end if</font>;
           <font color="blue">end if</font>;
        <font color="blue">else</font>
           swap := false;
        <font color="blue">end if</font>;

        <font color="blue">while </font>swap<font color="blue"> loop</font>
           wv := sorted_v[j+1];
           wi := indices[j+1];
           sorted_v[j+1] := sorted_v[j+gap+1];
           sorted_v[j+gap+1] := wv;
           indices[j+1] := indices[j+gap+1];
           indices[j+gap+1] := wi;
           j := j - gap;
           <font color="blue">if </font>j &gt;= 0<font color="blue"> then</font>
              k1 := j+1;
              k2 := j + gap + 1;
              <font color="blue">if </font>sortFrequency<font color="blue"> then</font>
                 <font color="blue">if </font>ascending<font color="blue"> then</font>
                    swap :=<font color="red"> abs</font>(sorted_v[k1].im) &gt;<font color="red">  abs</font>(sorted_v[k2].im)<font color="blue"> or </font>
                            <font color="red">abs</font>(sorted_v[k1].im) ==<font color="red"> abs</font>(sorted_v[k2].im)<font color="blue"> and </font>
                            (sorted_v[k1].re  &gt; sorted_v[k2].re<font color="blue"> or </font>
                             sorted_v[k1].re  == sorted_v[k2].re<font color="blue"> and </font>sorted_v[k1].im &lt; sorted_v[k2].im);
                 <font color="blue">else</font>
                    swap :=<font color="red"> abs</font>(sorted_v[k1].im) &lt;<font color="red">  abs</font>(sorted_v[k2].im)<font color="blue"> or </font>
                            <font color="red">abs</font>(sorted_v[k1].im) ==<font color="red"> abs</font>(sorted_v[k2].im)<font color="blue"> and </font>
                            (sorted_v[k1].re  &lt; sorted_v[k2].re<font color="blue"> or </font>
                             sorted_v[k1].re  == sorted_v[k2].re<font color="blue"> and </font>sorted_v[k1].im &lt; sorted_v[k2].im);
                 <font color="blue">end if</font>;
              <font color="blue">else</font>
                 <font color="blue">if </font>ascending<font color="blue"> then</font>
                    swap :=<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k1]) &gt;<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k2]);
                 <font color="blue">else</font>
                    swap :=<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k1]) &lt;<font color="red"> ComplexMath.&#39;abs&#39;</font>(sorted_v[k2]);
                 <font color="blue">end if</font>;
              <font color="blue">end if</font>;
           <font color="blue">else</font>
              swap := false;
           <font color="blue">end if</font>;
        <font color="blue">end while</font>;
        i := i + 1;
     <font color="blue">end while</font>;
     gap :=<font color="red"> div</font>(gap,2);
  <font color="blue">end while</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>sort;
</PRE>
<HR>
<address><a href="http://www.3ds.com/">Automatically generated</a> Fri Nov 12 16:31:49 2010.
</address></BODY>
</HTML>
